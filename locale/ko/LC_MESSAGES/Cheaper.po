# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2012-2016, uWSGI
# This file is distributed under the same license as the uWSGI package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2019.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: uWSGI 2.0\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2019-05-09 10:15+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.6.0\n"

#: ../../Cheaper.rst:2
msgid "The uWSGI cheaper subsystem -- adaptive process spawning"
msgstr ""

#: ../../Cheaper.rst:4
msgid ""
"uWSGI provides the ability to dynamically scale the number of running "
"workers via pluggable algorithms.  Use ``uwsgi --cheaper-algos-list`` to "
"get the list of available algorithms."
msgstr ""

#: ../../Cheaper.rst:9
msgid "Usage"
msgstr ""

#: ../../Cheaper.rst:11
msgid ""
"To enable cheaper mode add the ``cheaper = N`` option to the uWSGI "
"configuration file, where N is the minimum number of workers uWSGI can "
"run. The ``cheaper`` value must be lower than the maximum number of "
"configured workers (``workers`` or ``processes`` option)."
msgstr ""

#: ../../Cheaper.rst:34
msgid ""
"This configuration will tell uWSGI to run up to 10 workers under load. If"
" the app is idle uWSGI will stop workers but it will always leave at "
"least 2 of them running.  With ``cheaper-initial`` you can control how "
"many workers should be spawned at startup. If your average load requires "
"more than minimum number of workers you can have them spawned right away "
"and then \"cheaped\" (killed off) if load is low enough.  When the "
"cheaper algorithm decides that it needs more workers it will spawn "
"``cheaper-step`` of them. This is useful if you have a high maximum "
"number of workers -- in the event of a sudden load spike it would "
"otherwise take a lot of time to spawn enough workers one by one."
msgstr ""

#: ../../Cheaper.rst:44
msgid ""
"Note: Worker is notified by uWSGI before being cheaped. Worker should "
"finish until timeout is reached (this is configured by ``worker-reload-"
"mercy`` configuration parameter). Otherwise, uWSGI kills the worker. "
"Killing worker in the middle of serving request can cause errors or "
"partial responses to the client."
msgstr ""

#: ../../Cheaper.rst:50
msgid "Setting memory limits"
msgstr ""

#: ../../Cheaper.rst:52
msgid ""
"Starting with 1.9.16 rss memory limits can be set to stop cheaper "
"spawning new workers if process count limit was not reached, but total "
"sum of rss memory used by all workers reached given limit."
msgstr ""

#: ../../Cheaper.rst:68
msgid "Notes:"
msgstr ""

#: ../../Cheaper.rst:70
msgid "Hard limit is optional, soft limit alone can be used."
msgstr ""

#: ../../Cheaper.rst:71
msgid ""
"Hard value must be higher then soft value, both values shouldn't be too "
"close to each other."
msgstr ""

#: ../../Cheaper.rst:72
msgid ""
"Hard value should be soft + at least average worker memory usage for "
"given app."
msgstr ""

#: ../../Cheaper.rst:73
msgid ""
"Soft value is the limiter for cheaper, it won't spawn more workers, but "
"already running workers memory usage might grow, to handle that reload-"
"on-rss can be set too. To set unbreakable barrier for app memory usage "
"cgroups are recommended."
msgstr ""

#: ../../Cheaper.rst:79
msgid "``spare`` cheaper algorithm"
msgstr ""

#: ../../Cheaper.rst:81
msgid ""
"This is the default algorithm.  If all workers are busy for "
"``cheaper_overload`` seconds then uWSGI will spawn new workers. When the "
"load is gone it will begin stopping processes one at a time."
msgstr ""

#: ../../Cheaper.rst:87
msgid "``spare2`` cheaper algorithm"
msgstr ""

#: ../../Cheaper.rst:89
msgid ""
"This algorithm is similar to spare, but suitable for large scale by "
"increase workers faster and decrease workers slower."
msgstr ""

#: ../../Cheaper.rst:92
msgid ""
"When number of idle workers is smaller than number specified by "
"``cheaper``, it spawns (``cheaper`` - number of idle workers) workers.  "
"Maximum workers spawned at once can be limited by ``cheaper-step``. For "
"example, ``cheaper`` is 4, there are 2 idle workers and ``cheaper-step`` "
"is 1, it spawns 1 worker."
msgstr ""

#: ../../Cheaper.rst:96
msgid ""
"When number of idle workers is larger than ``cheaper``, it increments "
"internal counter. When number of idle workers is smaller than or equal to"
" ``cheaper``, reset the counter. When the counter is equal to ``cheaper-"
"idle``, cheap one worker and reset the counter."
msgstr ""

#: ../../Cheaper.rst:100
msgid "Sample configuration:"
msgstr ""

#: ../../Cheaper.rst:114
msgid "``backlog`` cheaper algorithm"
msgstr ""

#: ../../Cheaper.rst:116
msgid ""
"``backlog`` is only available on Linux and only on TCP sockets (not UNIX "
"domain sockets)."
msgstr ""

#: ../../Cheaper.rst:118
msgid ""
"If the socket's listen queue has more than ``cheaper_overload`` requests "
"waiting to be processed, uWSGI will spawn new workers.  If the backlog is"
" lower it will begin killing processes one at a time."
msgstr ""

#: ../../Cheaper.rst:123
msgid "``busyness`` cheaper algorithm"
msgstr ""

#: ../../Cheaper.rst:125
msgid ""
"This algorithm is optional, it is only available if the "
"``cheaper_busyness`` plugin is compiled and loaded."
msgstr ""

#: ../../Cheaper.rst:127
msgid ""
"This plugin implements an algorithm which adds or removes workers based "
"on average utilization for a given time period. It's goal is to keep more"
" workers than the minimum needed available at any given time, so the app "
"will always have capacity for new requests. If you want to run only "
"minimum number of workers then use the spare or backlog algorithms."
msgstr ""

#: ../../Cheaper.rst:133
msgid ""
"This plugin primarily is used because the way spare and backlog plugins "
"work causes very aggressive scaling behavior. If you set a low "
"``cheaper`` value (for example 1), then uWSGI will keep only 1 worker "
"running and spawn new workers only when that running worker is "
"overloaded.  If an app requires more workers, then uWSGI will be spawning"
" and stopping workers all the time. Only during times of very low load "
"the would the minimum number of workers be enough."
msgstr ""

#: ../../Cheaper.rst:141
msgid ""
"The Busyness algorithm tries to do the opposite: spawn as many workers as"
" needed and stop some of them only when there is a good chance that they "
"are not needed. This should lead to a more stable worker count and much "
"less respawns. Since for most of the time we have more worker capacity  "
"than actually needed, average application response times should be lower "
"than with other plugins."
msgstr ""

#: ../../Cheaper.rst:147
msgid "Options:"
msgstr ""

#: ../../Cheaper.rst:150
msgid "cheaper-overload"
msgstr ""

#: ../../Cheaper.rst:152
msgid ""
"Specifies the window, in seconds, for tracking the average busyness of "
"workers. Example:"
msgstr ""

#: ../../Cheaper.rst:158
msgid ""
"This option will check busyness every 30 seconds. If during the last 30 "
"seconds all workers were running for 3 seconds and idle for the remaining"
" 27 seconds the calculated busyness will be 10% (3/30). This value will "
"decide how fast uWSGI can respond to load spikes. New workers will be "
"spawned at most every ``cheaper-overload`` seconds (unless you are "
"running uWSGI on Linux -- see ``cheaper-busyness-backlog-alert`` for "
"details)."
msgstr ""

#: ../../Cheaper.rst:165
msgid ""
"If you want to react to load spikes faster, keep this value low so "
"busyness is calculated more often. Keep in mind this may cause workers to"
" be started/stopped more often than required since every minor spike may "
"spawn new workers. With a high ``cheaper-overload`` value the worker "
"count will change much less since longer cycles will eat all short spikes"
" of load and extreme values. Default is 3, for busyness plugin it's best "
"to use higher value (10-30)."
msgstr ""

#: ../../Cheaper.rst:174
msgid "cheaper-step"
msgstr ""

#: ../../Cheaper.rst:176
msgid ""
"How many workers to spawn when the algorithm decides they are needed. "
"Default is 1."
msgstr ""

#: ../../Cheaper.rst:180
msgid "cheaper-initial"
msgstr ""

#: ../../Cheaper.rst:182
msgid ""
"The number of workers to be started when starting the application. After "
"the app is started the algorithm can stop or start workers if needed."
msgstr ""

#: ../../Cheaper.rst:186
msgid "cheaper-busyness-max"
msgstr ""

#: ../../Cheaper.rst:188
msgid ""
"This is the maximum busyness we allow. Every time the calculated busyness"
" for last ``cheaper-overload`` seconds is higher than this value, uWSGI "
"will spawn ``cheaper-step`` new workers.  Default is 50."
msgstr ""

#: ../../Cheaper.rst:193
msgid "cheaper-busyness-min"
msgstr ""

#: ../../Cheaper.rst:195
msgid ""
"This is minimum busyness. If current busyness is below this value, the "
"app is considered as being in an \"idle cycl\" and uWSGI will start "
"counting them. Once we reach needed number of idle cycles uWSGI will kill"
" one worker.  Default is 25."
msgstr ""

#: ../../Cheaper.rst:201
msgid "cheaper-busyness-multiplier"
msgstr ""

#: ../../Cheaper.rst:203
msgid ""
"This option tells uWSGI how many idle cycles we need before stopping a "
"worker. After reaching this limit uWSGI will stop a worker and reset this"
" counter."
msgstr ""

#: ../../Cheaper.rst:206
msgid "For example:"
msgstr ""

#: ../../Cheaper.rst:214
#, python-format
msgid ""
"If average worker busyness is under 25% for 20 checks in a row, executed "
"every 10 seconds (total of 200 seconds), one worker will be stopped. The "
"idle cycles counter will be reset if average busyness jumps above "
"``cheaper-busyness-max`` and we spawn new workers. If during idle cycle "
"counting the average busyness jumps above ``cheaper-busyness-min`` but "
"still below ``cheaper-busyness-max``, then the idle cycles counter is "
"adjusted and we need to wait extra one idle cycle. If during idle cycle "
"counting the average busyness jumps above ``cheaper-busyness-min`` but "
"still below ``cheaper-busyness-max`` three times in a row, then the idle "
"cycle counter is reset."
msgstr ""

#: ../../Cheaper.rst:225
msgid "cheaper-busyness-penalty"
msgstr ""

#: ../../Cheaper.rst:227
msgid ""
"uWSGI will automatically tune the number of idle cycles needed to stop "
"worker when worker is stopped due to enough idle cycles and then spawned "
"back to fast (less than the same time we need to cheap worker), then we "
"will increment the ``cheaper-busyness-multiplier`` value this value.  "
"Default is 1."
msgstr ""

#: ../../Cheaper.rst:232
msgid "Example:"
msgstr ""

#: ../../Cheaper.rst:241
#, python-format
msgid ""
"If average worker busyness is under 25% for 20 checks in a row, executed "
"every 10 seconds (total 200 seconds), one worker will be stopped. If new "
"worker is spawned in less than 200 seconds (counting from the time when "
"we spawned the last worker before it), the ``cheaper-busyness-"
"multiplier`` value will be incremented up to 22 (20+2). Now we will need "
"to wait 220 seconds (22*10) to cheap another worker.  This option is used"
" to prevent workers from being started and stopped all the time since "
"once we stop one worker, busyness might jump up enough to hit ``cheaper-"
"busyness-max``. Without this, or if tuned poorly, we can get into a "
"stop/start feedback loop ."
msgstr ""

#: ../../Cheaper.rst:252
msgid "cheaper-busyness-verbose"
msgstr ""

#: ../../Cheaper.rst:254
msgid "This option enables debug logs from the ``cheaper_busyness`` plugin."
msgstr ""

#: ../../Cheaper.rst:257
msgid "cheaper-busyness-backlog-alert"
msgstr ""

#: ../../Cheaper.rst:259
msgid ""
"This option is only available on Linux. It is used to allow quick "
"response to load spikes even with high ``cheaper-overload`` values. On "
"every uWSGI master cycle (default 1 second) the current listen queue is "
"checked. If it is higher than this value, an emergency worker is spawned."
" When using this option it is safe to use high ``cheaper-overload`` "
"values to have smoother scaling of worker count. Default is 33."
msgstr ""

#: ../../Cheaper.rst:267
msgid "cheaper-busyness-backlog-multiplier"
msgstr ""

#: ../../Cheaper.rst:269
msgid ""
"This option is only available on Linux. It works just like ``cheaper-"
"busyness-multiplier``, except it is used only for emergency workers "
"spawned when listen queue was higher than ``cheaper-busyness-backlog-"
"alert``."
msgstr ""

#: ../../Cheaper.rst:273
msgid ""
"Emergency workers are spawned in case of big load spike to prevent "
"currently running workers from being overloaded. Sometimes load spike are"
" random and short which can spawn a lot of emergency workers. In such "
"cases we would need to wait several cycles before reaping those workers. "
"This provides an alternate multiplier to reap these processes faster.  "
"Default is 3."
msgstr ""

#: ../../Cheaper.rst:280
msgid "cheaper-busyness-backlog-step"
msgstr ""

#: ../../Cheaper.rst:282
msgid ""
"This option is only available on Linux. It sets the number of emergency "
"workers spawned when listen queue is higher than ``cheaper-busyness-"
"backlog-alert``. Defaults to 1."
msgstr ""

#: ../../Cheaper.rst:287
msgid "cheaper-busyness-backlog-nonzero"
msgstr ""

#: ../../Cheaper.rst:289
msgid ""
"This option is only available on Linux. It will spawn new emergency "
"workers if the request listen queue is > 0 for more than N seconds.  It "
"is used to protect the server from the corner case where there is only a "
"single worker running and the worker is handling a long running request. "
"If uWSGI receives new requests they would stay in the request queue until"
" that long running request is completed. With this option we can detect "
"such a condition and spawn new worker to prevent queued requests from "
"being timed out.  Default is 60."
msgstr ""

#: ../../Cheaper.rst:298
msgid "Notes regarding Busyness"
msgstr ""

#: ../../Cheaper.rst:300
msgid ""
"Experiment with settings, there is no one golden rule of what values "
"should be used for everyone. Test and pick values that are best for you. "
"Monitoring uWSGI stats (via Carbon, for instance) will make it easy to "
"decide on good values."
msgstr ""

#: ../../Cheaper.rst:301
msgid ""
"Don't expect busyness to be constant. it will change frequently. In the "
"end, real users interact with your apps in very random way. It's "
"recommended to use longer --cheaper-overload values (>=30) to have less "
"spikes."
msgstr ""

#: ../../Cheaper.rst:302
msgid ""
"If you want to run some benchmarks with this plugin, you should use tools"
" that add randomness to the work load"
msgstr ""

#: ../../Cheaper.rst:303
msgid ""
"With a low number of workers (2-3) starting new worker or stopping one "
"might affect busyness a lot, if You have 2 workers with busyness of 50%, "
"than stopping one of them will increase busyness to 100%. Keep that in "
"mind when picking min and max levels, with only few workers running most "
"of the time max should be more than double of min, otherwise every time "
"one worker is stopped it might increase busyness to above max level."
msgstr ""

#: ../../Cheaper.rst:304
msgid ""
"With a low number of workers (1-4) and default settings expect this "
"plugin will keep average busyness below the minimum level; adjust levels "
"to compensate for this."
msgstr ""

#: ../../Cheaper.rst:305
msgid ""
"With a higher number of workers required to handle load, worker count "
"should stabilize somewhere near minimum busyness level, jumping a little "
"bit around this value"
msgstr ""

#: ../../Cheaper.rst:306
msgid ""
"When experimenting with this plugin it is advised to enable ``--cheaper-"
"busyness-verbose`` to get an idea of what it is doing. An example log "
"follows."
msgstr ""

