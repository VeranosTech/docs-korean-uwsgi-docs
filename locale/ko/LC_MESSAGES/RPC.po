# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2012-2016, uWSGI
# This file is distributed under the same license as the uWSGI package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2019.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: uWSGI 2.0\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2019-05-09 10:15+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.6.0\n"

#: ../../RPC.rst:2
msgid "uWSGI RPC Stack"
msgstr ""

#: ../../RPC.rst:4
msgid "uWSGI contains a fast, simple, pan-and-cross-language RPC stack."
msgstr ""

#: ../../RPC.rst:6
msgid ""
"Although you may fall in love with this subsystem, try to use it only "
"when you need it. There are plenty of higher-level RPC technologies "
"better suited for the vast majority of situations."
msgstr ""

#: ../../RPC.rst:8
msgid ""
"That said, the uWSGI RPC subsystem shines with its performance and memory"
" usage. As an example, if you need to split the load of a request to "
"multiple servers, the uWSGI RPC is a great choice, as it allows you to "
"offload tasks with very little effort."
msgstr ""

#: ../../RPC.rst:10
msgid "Its biggest limit is in its \"typeless\" approach."
msgstr ""

#: ../../RPC.rst:12
msgid ""
"RPC functions can take up to 254 args. Each argument has to be a string "
"with a 16 bit maximum size (65535 bytes), while the return value has to "
"be a string (this time 64-bit, so that's not a practical limit)."
msgstr ""

#: ../../RPC.rst:14
msgid ""
"64 bit response length has been implemented only in uWSGI 1.9.20, older "
"releases have 16 bit response length limit."
msgstr ""

#: ../../RPC.rst:16
msgid ""
"RPC functions receive arguments in the form of binary strings, so every "
"RPC exportable function must assume that each argument is a string. Every"
" RPC function returns a binary string of 0 or more characters."
msgstr ""

#: ../../RPC.rst:18
msgid ""
"So, if you need \"elegance\" or strong typing, just look in another place"
" (or roll your own typing on top of uWSGI RPC, maybe...)."
msgstr ""

#: ../../RPC.rst:20
msgid ""
"Since 1.9 the RPC subsystem is fully async-friendly, so you can use it "
"with gevent and Coro::AnyEvent etc."
msgstr ""

#: ../../RPC.rst:23
msgid "Learning by example"
msgstr ""

#: ../../RPC.rst:25
msgid ""
"Let's start with a simple RPC call from ``10.0.0.1:3031`` to "
"``10.0.0.2:3031``."
msgstr ""

#: ../../RPC.rst:27
msgid "So let's export a \"hello\" function on ``.2``."
msgstr ""

#: ../../RPC.rst:38
msgid ""
"This uses :py:meth:`uwsgi.register_rpc` to declare a function called "
"\"hello\" to be exported. We'll start the server with ``--socket :3031``."
msgstr ""

#: ../../RPC.rst:40
msgid ""
"On the caller's side, on ``10.0.0.1``, let's declare the world's (second)"
" simplest WSGI app."
msgstr ""

#: ../../RPC.rst:50
msgid "That's it!"
msgstr ""

#: ../../RPC.rst:53
msgid "You need Perl?"
msgstr ""

#: ../../RPC.rst:64
msgid "Or perhaps you want to call an RPC function from a standalone perl script?"
msgstr ""

#: ../../RPC.rst:73
msgid "What about, let's say, Lua?"
msgstr ""

#: ../../RPC.rst:75
msgid "Glad you asked. If you want to export functions in Lua, simply do:"
msgstr ""

#: ../../RPC.rst:85
msgid "And in your Python WSGI app:"
msgstr ""

#: ../../RPC.rst:96
msgid "And other languages/platforms?"
msgstr ""

#: ../../RPC.rst:98
msgid ""
"Check the language specific docs, basically all of them should support "
"registering and calling RPC functions."
msgstr ""

#: ../../RPC.rst:100
msgid ""
"You can build multi-languages app with really no effort at all and will "
"be happily surprised about how easy it is to call :doc:`Java<JVM>` "
"functions from Perl, JavaScript from Python and so on."
msgstr ""

#: ../../RPC.rst:104
msgid "Doing RPC locally"
msgstr ""

#: ../../RPC.rst:106
msgid ""
"Doing RPC locally may sound a little silly, but if you need to call a Lua"
" function from Python with the absolute least possible overhead, uWSGI "
"RPC is your man."
msgstr ""

#: ../../RPC.rst:108
msgid ""
"If you want to call a RPC defined in the same server (governed by the "
"same master, etc.), simply set the first parameter of ``uwsgi.rpc`` to "
"None or nil, or use the convenience function :py:meth:`uwsgi.call`."
msgstr ""

#: ../../RPC.rst:111
msgid "Doing RPC from the internal routing subsystem"
msgstr ""

#: ../../RPC.rst:113
msgid "The RPC plugin exports a bunch of internal routing actions:"
msgstr ""

#: ../../RPC.rst:115
msgid "`rpc` call the specified rpc function and send the response to the client"
msgstr ""

#: ../../RPC.rst:116
msgid ""
"`rpcnext/rpcblob` call the specified rpc function, send the response to "
"the client and continue to the next rule"
msgstr ""

#: ../../RPC.rst:117
msgid ""
"`rpcret` calls the specified rpc function and uses its return value as "
"the action return code (next, continue, goto ...)"
msgstr ""

#: ../../RPC.rst:130
msgid "Doing RPC from nginx"
msgstr ""

#: ../../RPC.rst:132
msgid ""
"As Nginx supports low-level manipulation of the uwsgi packets sent to "
"upstream uWSGI servers, you can do RPC directly through it. Madness!"
msgstr ""

#: ../../RPC.rst:149
msgid ""
"Zero size strings will be ignored by the uWSGI array parser, so you can "
"safely use them when the numbers of parameters + function_name is not "
"even."
msgstr ""

#: ../../RPC.rst:151
msgid ""
"Modifier2 is set to 1 to inform that raw strings (HTTP responses in this "
"case) are received. Otherwise the RPC subsystem would encapsulate the "
"output in an uwsgi protocol packet, and nginx isn't smart enough to read "
"those."
msgstr ""

#: ../../RPC.rst:155
msgid "HTTP PATH_INFO -> RPC bridge"
msgstr ""

#: ../../RPC.rst:158
msgid "XML-RPC -> RPC bridge"
msgstr ""

