# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2012-2016, uWSGI
# This file is distributed under the same license as the uWSGI package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2019.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: uWSGI 2.0\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2019-05-09 10:15+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.6.0\n"

#: ../../articles/SerializingAccept.rst:2
msgid "Serializing accept(), AKA Thundering Herd, AKA the Zeeg Problem"
msgstr ""

#: ../../articles/SerializingAccept.rst:4
msgid ""
"One of the historical problems in the UNIX world is the \"thundering "
"herd\"."
msgstr ""

#: ../../articles/SerializingAccept.rst:6
msgid "What is it?"
msgstr ""

#: ../../articles/SerializingAccept.rst:8
msgid ""
"Take a process binding to a networking address (it could be ``AF_INET``, "
"``AF_UNIX`` or whatever you want) and then forking itself:"
msgstr ""

#: ../../articles/SerializingAccept.rst:18
msgid ""
"After having forked itself a bunch of times, each process will generally "
"start blocking on ``accept()``"
msgstr ""

#: ../../articles/SerializingAccept.rst:29
msgid ""
"The funny problem is that on older/classic UNIX, ``accept()`` is woken up"
" in each process blocked on it whenever a connection is attempted on the "
"socket."
msgstr ""

#: ../../articles/SerializingAccept.rst:32
msgid ""
"Only one of those processes will be able to truly accept the connection, "
"the others will get a boring ``EAGAIN``."
msgstr ""

#: ../../articles/SerializingAccept.rst:35
msgid ""
"This results in a vast number of wasted cpu cycles (the kernel scheduler "
"has to give control to all of the sleeping processes waiting on that "
"socket)."
msgstr ""

#: ../../articles/SerializingAccept.rst:38
msgid ""
"This behaviour (for various reasons) is amplified when instead of "
"processes you use threads (so, you have multiple threads blocked on "
"``accept()``)."
msgstr ""

#: ../../articles/SerializingAccept.rst:41
msgid ""
"The de facto solution was placing a lock before the ``accept()`` call to "
"serialize its usage:"
msgstr ""

#: ../../articles/SerializingAccept.rst:54
msgid ""
"For threads, dealing with locks is generally easier but for processes you"
" have to fight with system-specific solutions or fall back to the "
"venerable SysV ipc subsystem (more on this later)."
msgstr ""

#: ../../articles/SerializingAccept.rst:58
msgid ""
"In modern times, the vast majority of UNIX systems have evolved, and now "
"the kernel ensures (more or less) only one process/thread is woken up on "
"a connection event."
msgstr ""

#: ../../articles/SerializingAccept.rst:62
msgid "Ok, problem solved, what we are talking about?"
msgstr ""

#: ../../articles/SerializingAccept.rst:65
msgid "select()/poll()/kqueue()/epoll()/..."
msgstr ""

#: ../../articles/SerializingAccept.rst:67
msgid ""
"In the pre-1.0 era, uWSGI was a lot simpler (and less interesting) than "
"the current form. It did not have the signal framework and it was not "
"able to listen to multiple addresses; for this reason its loop engine was"
" only calling ``accept()`` in each process/thread, and thundering herd "
"(thanks to modern kernels) was not a problem."
msgstr ""

#: ../../articles/SerializingAccept.rst:73
msgid ""
"Evolution has a price, so after a while the standard loop engine of a "
"uWSGI process/thread moved from:"
msgstr ""

#: ../../articles/SerializingAccept.rst:84
msgid "to a more complex:"
msgstr ""

#: ../../articles/SerializingAccept.rst:100
msgid ""
"The problem is now the ``wait_for_fds()`` example function: it will call "
"something like ``select()``, ``poll()`` or the more modern ``epoll()`` "
"and ``kqueue()``."
msgstr ""

#: ../../articles/SerializingAccept.rst:104
msgid ""
"These kinds of system calls are \"monitors\" for file descriptors, and "
"they are woken up in all of the processes/threads waiting for the same "
"file descriptor."
msgstr ""

#: ../../articles/SerializingAccept.rst:107
msgid ""
"Before you start blaming your kernel developers, this is the right "
"approach, as the kernel cannot know if you are waiting for those file "
"descriptors to call ``accept()`` or to make something funnier."
msgstr ""

#: ../../articles/SerializingAccept.rst:111
msgid "So, welcome again to the thundering herd."
msgstr ""

#: ../../articles/SerializingAccept.rst:114
msgid "Application Servers VS WebServers"
msgstr ""

#: ../../articles/SerializingAccept.rst:116
msgid ""
"The popular, battle tested, solid, multiprocess reference webserver is "
"Apache HTTPD."
msgstr ""

#: ../../articles/SerializingAccept.rst:119
msgid ""
"It survived decades of IT evolutions and it's still one of the most "
"important technologies powering the whole Internet."
msgstr ""

#: ../../articles/SerializingAccept.rst:122
msgid ""
"Born as multiprocess-only, Apache had to always deal with the thundering "
"herd problem and they solved it using SysV ipc semaphores."
msgstr ""

#: ../../articles/SerializingAccept.rst:125
msgid ""
"(Note: Apache is really smart about that, when it only needs to wait on a"
" single file descriptor, it only calls ``accept()`` taking advantage of "
"modern kernels anti-thundering herd policies)"
msgstr ""

#: ../../articles/SerializingAccept.rst:129
msgid ""
"(Update: Apache 2.x even allows you to choose which lock technique to "
"use, included flock/fcntl for very ancient systems, but on the vast "
"majority of the system, when in multiprocess mode it will use the sysv "
"semaphores)"
msgstr ""

#: ../../articles/SerializingAccept.rst:133
msgid ""
"Even on modern Apache releases, stracing one of its process (bound to "
"multiple interfaces) you will see something like that (it is a Linux "
"system):"
msgstr ""

#: ../../articles/SerializingAccept.rst:144
msgid "the SysV semaphore protect your epoll_wait from thundering herd."
msgstr ""

#: ../../articles/SerializingAccept.rst:146
msgid ""
"So, another problem solved, the world is a such a beautiful place... but "
"...."
msgstr ""

#: ../../articles/SerializingAccept.rst:148
msgid "**SysV IPC is not good for application servers :(***"
msgstr ""

#: ../../articles/SerializingAccept.rst:150
msgid ""
"The definition of \"application server\" is pretty generic, in this case "
"we refer to one or more process/processes generated by an unprivileged "
"(non-root) user binding on one or more network address and running "
"custom, highly non-deterministic code."
msgstr ""

#: ../../articles/SerializingAccept.rst:155
msgid ""
"Even if you had a minimal/basic knowledge on how SysV IPC works, you will"
" know each of its components is a limited resource in the system (and in "
"modern BSDs these limits are set to ridiculously low values, PostgreSQL "
"FreeBSD users know this problem very well)."
msgstr ""

#: ../../articles/SerializingAccept.rst:160
msgid ""
"Just run 'ipcs' in your terminal to get a list of the allocated objects "
"in your kernel. Yes, in your kernel. SysV ipc objects are persistent "
"resources, they need to be removed manually by the user. The same user "
"that could allocate hundreds of those objects and fill your limited SysV "
"IPC memory."
msgstr ""

#: ../../articles/SerializingAccept.rst:165
msgid ""
"One of the most common problems in the Apache world caused by the SysV "
"ipc usage is the leakage when you brutally kill Apache instances (yes, "
"you should never do it, but you don't have a choice if you are so "
"brave/fool to host unreliable PHP apps in your webserver process)."
msgstr ""

#: ../../articles/SerializingAccept.rst:170
msgid ""
"To better understand it, spawn Apache and ``killall -9 apache2``. Respawn"
" it and run 'ipcs' you will get a new semaphore object every time. Do you"
" see the problem? (to Apache gurus: yes I know there are hacky tricks to "
"avoid that, but this is the default behaviour)"
msgstr ""

#: ../../articles/SerializingAccept.rst:175
msgid ""
"Apache is generally a system service, managed by a conscious sysadmin, so"
" except few cases you can continue trusting it for more decades, even if "
"it decides to use more SysV ipc objects :)"
msgstr ""

#: ../../articles/SerializingAccept.rst:179
msgid ""
"Your application server, sadly, is managed by different kind of users, "
"from the most skilled one to the one who should change job as soon as "
"possible to the one with the site cracked by a moron wanting to take "
"control of your server."
msgstr ""

#: ../../articles/SerializingAccept.rst:183
msgid ""
"Application servers are not dangerous, users are. And application servers"
" are run by users. The world is an ugly place."
msgstr ""

#: ../../articles/SerializingAccept.rst:187
msgid "How application server developers solved it"
msgstr ""

#: ../../articles/SerializingAccept.rst:189
msgid "Fast answer: they generally do not solve/care it"
msgstr ""

#: ../../articles/SerializingAccept.rst:191
msgid ""
"Note: we are talking about multiprocessing, we have already seen "
"multithreading is easy to solve."
msgstr ""

#: ../../articles/SerializingAccept.rst:194
msgid ""
"Serving static files or proxying (the main activities of a webserver) is "
"generally a fast, non-blocking (very deterministic under various points "
"of view) activity. Instead, a web application is way slower and heavier, "
"so, even on moderately loaded sites, the amount of sleeping processes is "
"generally low."
msgstr ""

#: ../../articles/SerializingAccept.rst:199
msgid ""
"On highly loaded sites you will pray for a free process, and in non-"
"loaded sites the thundering herd problem is completely irrelevant (unless"
" you are running your site on a 386)."
msgstr ""

#: ../../articles/SerializingAccept.rst:203
msgid ""
"Given the relatively low number of processes you generally allocate for "
"an application server, we can say thundering herd is a no-problem."
msgstr ""

#: ../../articles/SerializingAccept.rst:206
msgid ""
"Another approach is dynamic process spawning. If you ensure your "
"application server has always the minimum required number of processes "
"running you will highly reduce the thundering herd problem. (check the "
"family of --cheaper uWSGI options)"
msgstr ""

#: ../../articles/SerializingAccept.rst:212
msgid "No-problem ??? So, again, what we are talking about ?"
msgstr ""

#: ../../articles/SerializingAccept.rst:214
msgid ""
"We are talking about \"common cases\", and for common cases there are a "
"plethora of valid choices (instead of uWSGI, obviously) and the vast "
"majority of problems we are talking about are non-existent."
msgstr ""

#: ../../articles/SerializingAccept.rst:218
msgid ""
"Since the beginning of the uWSGI project, being developed by a hosting "
"company where \"common cases\" do not exist, we cared a lot about corner-"
"case problems, bizarre setups and those problems the vast majority of "
"users never need to care about."
msgstr ""

#: ../../articles/SerializingAccept.rst:223
msgid ""
"In addition to this, uWSGI supports operational modes only "
"common/available in general-purpose webservers like Apache (I have to say"
" Apache is probably the only general purpose webserver as it allows "
"basically anything in its process space in a relatively safe and solid "
"way), so lot of new problems combined with user bad-behaviour arise."
msgstr ""

#: ../../articles/SerializingAccept.rst:229
msgid ""
"One of the most challenging development phase of uWSGI was adding "
"multithreading. Threads are powerful, but are really hard to manage in "
"the right way."
msgstr ""

#: ../../articles/SerializingAccept.rst:233
msgid ""
"Threads are way cheaper than processes, so you generally allocate dozens "
"of them for your app (remember, not used memory is wasted memory)."
msgstr ""

#: ../../articles/SerializingAccept.rst:236
msgid ""
"Dozens (or hundreds) of threads waiting for the same set of file "
"descriptors bring us back to a thundering herd problem (unless all of "
"your threads are constantly used)."
msgstr ""

#: ../../articles/SerializingAccept.rst:240
msgid ""
"For such a reason when you enable multiple threads in uWSGI a pthread "
"mutex is allocated, serializing epoll()/kqueue()/poll()/select()... usage"
" in each thread."
msgstr ""

#: ../../articles/SerializingAccept.rst:244
msgid ""
"Another problem solved (and strange for uWSGI, without the need of an "
"option ;)"
msgstr ""

#: ../../articles/SerializingAccept.rst:246
msgid "But..."
msgstr ""

#: ../../articles/SerializingAccept.rst:249
msgid "The Zeeg problem: Multiple processes with multiple threads"
msgstr ""

#: ../../articles/SerializingAccept.rst:251
msgid ""
"On June 27, 2013, David Cramer wrote an interesting blog post (you may "
"not agree with its conclusions, but it does not matter now, you can "
"continue hating uWSGI safely or making funny jokes about its naming "
"choices or the number of options)."
msgstr ""

#: ../../articles/SerializingAccept.rst:256
msgid "http://cramer.io/2013/06/27/serving-python-web-applications"
msgstr ""

#: ../../articles/SerializingAccept.rst:258
msgid ""
"The problem David faced was such a strong thundering herd that its "
"response time was damaged by it (non constant performance was the main "
"result of its tests)."
msgstr ""

#: ../../articles/SerializingAccept.rst:262
msgid "Why did it happen? Wasn't the mutex allocated by uWSGI solving it?"
msgstr ""

#: ../../articles/SerializingAccept.rst:264
msgid ""
"David is (was) running uWSGI with 10 process and each of them with 10 "
"threads:"
msgstr ""

#: ../../articles/SerializingAccept.rst:270
msgid ""
"While the mutex protects each thread in a single process to call "
"``accept()`` on the same request, there is no such mechanism (or better, "
"it is not enabled by default, see below) to protect multiple processes "
"from doing it, so given the number of threads (100) available for "
"managing requests, it is unlikely that a single process is completely "
"blocked (read: with all of its 10 threads blocked in a request) so "
"welcome back to the thundering herd."
msgstr ""

#: ../../articles/SerializingAccept.rst:278
msgid "How David solved it ?"
msgstr ""

#: ../../articles/SerializingAccept.rst:280
msgid ""
"uWSGI is a controversial piece of software, no shame in that. There are "
"users fiercely hating it and others morbidly loving it, but all agree "
"that docs could be way better ([OT] it is good when all the people agree "
"on something, but pull requests on uwsgi-docs are embarrassingly low and "
"all from the same people.... come on, help us !!!)"
msgstr ""

#: ../../articles/SerializingAccept.rst:286
msgid ""
"David used an empirical approach, spotted its problem and decided to "
"solve it running independent uwsgi processes bound on different sockets "
"and configured nginx to round robin between them."
msgstr ""

#: ../../articles/SerializingAccept.rst:290
msgid ""
"It is a very elegant approach, but it has a problem: nginx cannot know if"
" the process on which is sending the request has all of its thread busy. "
"It is a working but suboptimal solution."
msgstr ""

#: ../../articles/SerializingAccept.rst:294
msgid ""
"The best way would be having an inter-process locking (like Apache), "
"serializing all of the ``accept()`` in both threads and processes"
msgstr ""

#: ../../articles/SerializingAccept.rst:298
msgid "uWSGI docs sucks: --thunder-lock"
msgstr ""

#: ../../articles/SerializingAccept.rst:300
msgid ""
"Michael Hood (you will find his name in the comments of David's post, "
"too) signalled the problem in the uWSGI mailing-list/issue tracker some "
"time ago, he even came out with an initial patch that ended with the "
"``--thunder-lock`` option (this is why open-source is better ;)"
msgstr ""

#: ../../articles/SerializingAccept.rst:305
msgid ""
"``--thunder-lock`` is available since uWSGI 1.4.6 but never got "
"documentation (of any kind)"
msgstr ""

#: ../../articles/SerializingAccept.rst:308
msgid ""
"Only the people following the mailing-list (or facing the specific "
"problem) know about it."
msgstr ""

#: ../../articles/SerializingAccept.rst:312
msgid "SysV IPC semaphores are bad how you solved it ?"
msgstr ""

#: ../../articles/SerializingAccept.rst:314
msgid ""
"Interprocess locking has been an issue since uWSGI 0.0.0.0.0.1, but we "
"solved it in the first public release of the project (in 2009)."
msgstr ""

#: ../../articles/SerializingAccept.rst:317
msgid ""
"We basically checked each operating system capabilities and chose the "
"best/fastest ipc locking they could offer, filling our code with dozens "
"of #ifdef."
msgstr ""

#: ../../articles/SerializingAccept.rst:321
msgid ""
"When you start uWSGI you should see in its logs which \"lock engine\" has"
" been chosen."
msgstr ""

#: ../../articles/SerializingAccept.rst:324
msgid "There is support for a lot of them:"
msgstr ""

#: ../../articles/SerializingAccept.rst:326
msgid ""
"pthread mutexes with _PROCESS_SHARED and _ROBUST attributes (modern Linux"
" and Solaris)"
msgstr ""

#: ../../articles/SerializingAccept.rst:327
msgid "pthread mutexes with _PROCESS_SHARED (older Linux)"
msgstr ""

#: ../../articles/SerializingAccept.rst:328
msgid "OSX Spinlocks (MacOSX, Darwin)"
msgstr ""

#: ../../articles/SerializingAccept.rst:329
msgid "Posix semaphores (FreeBSD >= 9)"
msgstr ""

#: ../../articles/SerializingAccept.rst:330
msgid "Windows mutexes (Windows/Cygwin)"
msgstr ""

#: ../../articles/SerializingAccept.rst:331
msgid "SysV IPC semaphores (fallback for all the other systems)"
msgstr ""

#: ../../articles/SerializingAccept.rst:333
msgid ""
"Their usage is required for uWSGI-specific features like caching, rpc and"
" all of those features requiring changing shared memory structures "
"(allocated with mmap() + _SHARED)"
msgstr ""

#: ../../articles/SerializingAccept.rst:337
msgid ""
"Each of these engines is different from the others and dealing with them "
"has been a pain and (more important) some of them are not \"ROBUST\"."
msgstr ""

#: ../../articles/SerializingAccept.rst:340
msgid ""
"The \"ROBUST\" term is pthread-borrowed. If a lock is \"robust\", it "
"means if the process locking it dies, the lock is released."
msgstr ""

#: ../../articles/SerializingAccept.rst:343
msgid ""
"You would expect it from all of the lock engines, but sadly only few of "
"them works reliably."
msgstr ""

#: ../../articles/SerializingAccept.rst:346
msgid ""
"For this reason the uWSGI master process has to allocate an additional "
"thread (the 'deadlock' detector) constantly checking for non-robust "
"unreleased locks mapped to dead processes."
msgstr ""

#: ../../articles/SerializingAccept.rst:350
msgid ""
"It is a pain, however, anyone will tell you IPC locking is easy should be"
" accepted in a JEDI school..."
msgstr ""

#: ../../articles/SerializingAccept.rst:354
msgid "uWSGI developers are fu*!ing cowards"
msgstr ""

#: ../../articles/SerializingAccept.rst:356
msgid ""
"Both David Cramer and Graham Dumpleton (yes, he is the mod_wsgi author "
"but heavily contributed to uWSGI development as well to the other WSGI "
"servers, this is another reason why open source is better) asked why "
"``--thunder-lock`` is not the default when multiprocess + multithread is "
"requested."
msgstr ""

#: ../../articles/SerializingAccept.rst:361
msgid ""
"This is a good question with a simple answer: we are cowards who only "
"care about money."
msgstr ""

#: ../../articles/SerializingAccept.rst:364
msgid ""
"uWSGI is completely open source, but its development is sponsored (in "
"various way) by the companies using it and by Unbit.it customers."
msgstr ""

#: ../../articles/SerializingAccept.rst:367
msgid ""
"Enabling \"risky\" features by default for a \"common\" usage (like "
"multiprocess+multithread) is too much for us, and in addition to this, "
"the situation (especially on linux) of library/kernel incompatibilities "
"is a real pain."
msgstr ""

#: ../../articles/SerializingAccept.rst:372
msgid ""
"As an example for having ROBUST pthread mutexes you need a modern kernel "
"with a modern glibc, but commonly used distros (like the centos family) "
"have a mix of older kernels with newer glibc and the opposite too. This "
"leads to the inability to correctly detect which is the best locking "
"engine for a platform, and so, when the uwsgiconfig.py script is in doubt"
" it falls back to the safest approach (like non-robust pthread mutexes on"
" linux)."
msgstr ""

#: ../../articles/SerializingAccept.rst:379
msgid ""
"The deadlock-detector should save you from most of the problem, but the "
"\"should\" word is the key. Making a test suite (or even a single unit "
"test) on this kind of code is basically impossible (well, at least for "
"me), so we cannot be sure all is in the right place (and reporting "
"threading bugs is hard for users as well as skilled developer, unless you"
" work on pypy ;)"
msgstr ""

#: ../../articles/SerializingAccept.rst:385
#, python-format
msgid ""
"Linux pthread robust mutexes are solid, we are \"pretty\" sure about "
"that, so you should be able to enable ``--thunder-lock`` on modern Linux "
"systems with a 99.999999% success rates, but we prefer (for now) users "
"consciously enable it"
msgstr ""

#: ../../articles/SerializingAccept.rst:390
msgid "When SysV IPC semaphores are a better choice"
msgstr ""

#: ../../articles/SerializingAccept.rst:392
msgid ""
"Yes, there are cases on which SysV IPC semaphores gives you better "
"results than system-specific features."
msgstr ""

#: ../../articles/SerializingAccept.rst:395
msgid ""
"Marcin Deranek of Booking.com has been battle-testing uWSGI for months "
"and helped us with fixing corner-case situations even in the locking "
"area."
msgstr ""

#: ../../articles/SerializingAccept.rst:398
msgid ""
"He noted system-specific lock-engines tend to favour the kernel scheduler"
" (when choosing which process wins the next lock after an unlock) instead"
" of a round-robin distribution."
msgstr ""

#: ../../articles/SerializingAccept.rst:402
msgid ""
"As for their specific need for an equal distribution of requests among "
"processes is better (they use uWSGI with perl, so no threading is in "
"place, but they spawn lot of processes) they (currently) choose to use "
"the \"ipcsem\" lock engine with:"
msgstr ""

#: ../../articles/SerializingAccept.rst:411
msgid ""
"The funny thing (this time) is that you can easily test if the lock is "
"working well. Just start blasting the server and you will see in the "
"request logs how the reported pid is different each time, while with "
"system-specific locking the pids are pretty random with a pretty heavy "
"tendency of favouring the last used process."
msgstr ""

#: ../../articles/SerializingAccept.rst:417
msgid ""
"Funny enough, the first problem they faced was the ipcsem leakage (when "
"you are in emergency, graceful reload/stop is your enemy and kill -9 will"
" be your silver bullet)"
msgstr ""

#: ../../articles/SerializingAccept.rst:421
msgid ""
"To fix it, the --ftok option is available allowing you to give a unique "
"id to the semaphore object and to reuse it if it is available from a "
"previous run:"
msgstr ""

#: ../../articles/SerializingAccept.rst:428
msgid ""
"--ftok takes a file as an argument, it will use it to build the unique "
"id. A common pattern is using the pidfile for it"
msgstr ""

#: ../../articles/SerializingAccept.rst:433
msgid "What about other portable lock engines ?"
msgstr ""

#: ../../articles/SerializingAccept.rst:435
msgid "In addition to \"ipcsem\", uWSGI (where available) adds \"posixsem\" too."
msgstr ""

#: ../../articles/SerializingAccept.rst:437
msgid ""
"They are used by default only on FreeBSD >= 9, but are available on Linux"
" too."
msgstr ""

#: ../../articles/SerializingAccept.rst:439
msgid ""
"They are not \"ROBUST\", but they do not need shared kernel resources, so"
" if you trust our deadlock detector they are a pretty-good approach. "
"(Note: Graham Dumpleton pointed me to the fact they can be enabled on "
"Apache 2.x too)"
msgstr ""

#: ../../articles/SerializingAccept.rst:444
msgid "Conclusions"
msgstr ""

#: ../../articles/SerializingAccept.rst:446
msgid ""
"You can have the best (or the worst) software of the whole universe, but "
"without docs it does not exist."
msgstr ""

#: ../../articles/SerializingAccept.rst:449
msgid ""
"The Apache team still slam the face of the vast majority of us trying to "
"touch their market share :)"
msgstr ""

#: ../../articles/SerializingAccept.rst:453
msgid "Bonus chapter: using the Zeeg approach in a uWSGI friendly way"
msgstr ""

#: ../../articles/SerializingAccept.rst:455
msgid ""
"I have to admit, I am not a big fan of supervisord. It is a good software"
" without doubts, but I consider the Emperor and the --attach-daemon "
"facilities a better approach to the deployment problems. In addition to "
"this, if you want to have a \"scriptable\"/\"extendable\" process "
"supervisor I think Circus (https://circus.readthedocs.io/) is a lot more "
"fun and capable (the first thing I have done after implementing socket "
"activation in the uWSGI Emperor was making a pull request [merged, if you"
" care] for the same feature in Circus)."
msgstr ""

#: ../../articles/SerializingAccept.rst:463
msgid ""
"Obviously supervisord works and is used by lot of people, but as a heavy "
"uWSGI user I tend to abuse its features to accomplish a result."
msgstr ""

#: ../../articles/SerializingAccept.rst:466
msgid ""
"The first approach I would use is binding to 10 different ports and "
"mapping each of them to a specific process:"
msgstr ""

#: ../../articles/SerializingAccept.rst:489
msgid ""
"Now you have a master monitoring 5 processes, each one bound to a "
"different address (no ``--thunder-lock`` needed)"
msgstr ""

#: ../../articles/SerializingAccept.rst:492
msgid ""
"For the Emperor fanboys you can make such a template (call it "
"foo.template):"
msgstr ""

#: ../../articles/SerializingAccept.rst:501
msgid "Now make a symbolic link for each instance+port you want to spawn:"
msgstr ""

#: ../../articles/SerializingAccept.rst:513
msgid "Bonus chapter 2: securing SysV IPC semaphores"
msgstr ""

#: ../../articles/SerializingAccept.rst:515
msgid ""
"My company hosting platform in heavily based on Linux cgroups and "
"namespaces."
msgstr ""

#: ../../articles/SerializingAccept.rst:517
msgid ""
"The first (cgroups) are used to limit/account resource usage, while the "
"second (namespaces) are used to give an \"isolated\" system view to users"
" (like seeing a dedicated hostname or root filesystem)."
msgstr ""

#: ../../articles/SerializingAccept.rst:521
msgid ""
"As we allow users to spawn PostgreSQL instances in their accounts we need"
" to limit SysV objects."
msgstr ""

#: ../../articles/SerializingAccept.rst:524
msgid ""
"Luckily, modern Linux kernels have a namespace for IPC, so calling "
"unshare(CLONE_NEWIPC) will create a whole new set (detached from the "
"others) of IPC objects."
msgstr ""

#: ../../articles/SerializingAccept.rst:528
msgid ""
"Calling ``--unshare ipc`` in customer-dedicated Emperors is a common "
"approach. When combined with memory cgroup you will end with a pretty "
"secure setup."
msgstr ""

#: ../../articles/SerializingAccept.rst:533
msgid "Credits:"
msgstr ""

#: ../../articles/SerializingAccept.rst:535
msgid "Author: Roberto De Ioris"
msgstr ""

#: ../../articles/SerializingAccept.rst:537
msgid "Fixed by: Honza Pokorny"
msgstr ""

