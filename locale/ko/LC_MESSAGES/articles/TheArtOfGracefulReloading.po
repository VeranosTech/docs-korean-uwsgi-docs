# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2012-2016, uWSGI
# This file is distributed under the same license as the uWSGI package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2019.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: uWSGI 2.0\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2019-05-09 10:15+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.6.0\n"

#: ../../articles/TheArtOfGracefulReloading.rst:2
msgid "The Art of Graceful Reloading"
msgstr ""

#: ../../articles/TheArtOfGracefulReloading.rst:4
msgid "Author: Roberto De Ioris"
msgstr ""

#: ../../articles/TheArtOfGracefulReloading.rst:6
msgid ""
"The following article is language-agnostic, and albeit uWSGI-specific, "
"some of its initial considerations apply to other application servers and"
" platforms too."
msgstr ""

#: ../../articles/TheArtOfGracefulReloading.rst:10
msgid ""
"All of the described techniques assume a modern (>= 1.4) uWSGI release "
"with the master process enabled."
msgstr ""

#: ../../articles/TheArtOfGracefulReloading.rst:14
msgid "What is a \"graceful reload\"?"
msgstr ""

#: ../../articles/TheArtOfGracefulReloading.rst:16
msgid "During the life-cycle of your webapp you will reload it hundreds of times."
msgstr ""

#: ../../articles/TheArtOfGracefulReloading.rst:18
msgid ""
"You need reloading for code updates, you need reloading for changes in "
"the uWSGI configuration, you need reloading to reset the state of your "
"app."
msgstr ""

#: ../../articles/TheArtOfGracefulReloading.rst:21
msgid ""
"Basically, reloading is one of the most simple, frequent and "
"**dangerous** operation you do every time."
msgstr ""

#: ../../articles/TheArtOfGracefulReloading.rst:24
msgid "So, why \"graceful\"?"
msgstr ""

#: ../../articles/TheArtOfGracefulReloading.rst:26
msgid ""
"Take a traditional (and highly suggested) architecture: a proxy/load "
"balancer (like nginx) forwards requests to one or more uWSGI daemons "
"listening on various addresses."
msgstr ""

#: ../../articles/TheArtOfGracefulReloading.rst:30
msgid ""
"If you manage your reloads as \"stop the instance, start the instance\", "
"the time slice between two phases will result in a brutal disservice for "
"your customers."
msgstr ""

#: ../../articles/TheArtOfGracefulReloading.rst:33
msgid ""
"The main trick for avoiding it is: not closing the file descriptors "
"mapped to the uWSGI daemon addresses and abusing the Unix ``fork()`` "
"behaviour (read: file descriptors are inherited by default) to ``exec()``"
" the ``uwsgi`` binary again."
msgstr ""

#: ../../articles/TheArtOfGracefulReloading.rst:38
msgid ""
"The result is your proxy enqueuing requests to the socket until the "
"latter will be able to ``accept()`` them again, with the user/customer "
"only seeing a little slowdown in the first response (the time required "
"for the app to be fully loaded again)."
msgstr ""

#: ../../articles/TheArtOfGracefulReloading.rst:43
msgid ""
"Another important step of graceful reload is to avoid destroying "
"workers/threads that are still managing requests. Obviously requests "
"could be stuck, so you should have a timeout for running workers (in "
"uWSGI it is called the \"worker's mercy\" and it has a default value of "
"60 seconds)."
msgstr ""

#: ../../articles/TheArtOfGracefulReloading.rst:48
msgid ""
"These kind of tricks are pretty easy to accomplish and basically all of "
"the modern servers/application servers do it (more or less)."
msgstr ""

#: ../../articles/TheArtOfGracefulReloading.rst:51
msgid ""
"But, as always, the world is an ugly place and lot of problems arise, and"
" the \"inherited sockets\" approach is often not enough."
msgstr ""

#: ../../articles/TheArtOfGracefulReloading.rst:55
msgid "Things go wrong"
msgstr ""

#: ../../articles/TheArtOfGracefulReloading.rst:57
msgid ""
"We have seen that holding the uWSGI sockets alive allows the proxy "
"webserver to enqueue requests without spitting out errors to the clients."
" This is true only if your app restarts fast, and, sadly, this may not "
"always happen."
msgstr ""

#: ../../articles/TheArtOfGracefulReloading.rst:61
msgid ""
"Frameworks like Ruby on Rails or Zope start up really slow by default, "
"your app could start up slowly by itself, or your machine could be so "
"overloaded that every process spawn (``fork()``) takes ages."
msgstr ""

#: ../../articles/TheArtOfGracefulReloading.rst:65
msgid ""
"In addition to this, your site could be so famous that even if your app "
"restarts in a couple of seconds, the queue of your sockets could be "
"filled up forcing the proxy server to raise an error."
msgstr ""

#: ../../articles/TheArtOfGracefulReloading.rst:69
msgid ""
"Do not forget, your workers/threads that are still running requests could"
" block the reload (for various reasons) for more seconds than your proxy "
"server could tolerate."
msgstr ""

#: ../../articles/TheArtOfGracefulReloading.rst:73
msgid ""
"Finally, you could have made an application error in your just-committed "
"code, so uWSGI will not start, or will start sending wrong things or "
"errors..."
msgstr ""

#: ../../articles/TheArtOfGracefulReloading.rst:76
msgid "Reloads (brutal or graceful) can easily fail."
msgstr ""

#: ../../articles/TheArtOfGracefulReloading.rst:79
msgid "The listen queue"
msgstr ""

#: ../../articles/TheArtOfGracefulReloading.rst:81
msgid "Let's start with the dream of every webapp developer: *success*."
msgstr ""

#: ../../articles/TheArtOfGracefulReloading.rst:83
msgid ""
"Your app is visited by thousands of clients and you obviously make money "
"with it. Unfortunately, it is a very complex app and requires 10 seconds "
"to warm up."
msgstr ""

#: ../../articles/TheArtOfGracefulReloading.rst:86
msgid ""
"During graceful reloads, you expect new clients to wait 10 seconds (best "
"case) to start seeing contents, but, unfortunately, you have hundreds of "
"concurrent requests, so first 100 customers will wait during the server "
"warm-up, while the others will get an error from the proxy."
msgstr ""

#: ../../articles/TheArtOfGracefulReloading.rst:91
msgid ""
"This happens because the default size of uWSGI's listen queue is 100 "
"slots. Before you ask, it is an average value chosen by the maximum value"
" allowed by default by your kernel."
msgstr ""

#: ../../articles/TheArtOfGracefulReloading.rst:95
msgid ""
"Each operating system has a default limit (Linux has 128, for example), "
"so before increasing it you need to increase your kernel limit too."
msgstr ""

#: ../../articles/TheArtOfGracefulReloading.rst:98
msgid ""
"So, once your kernel is ready, you can increase the listen queue to the "
"maximum number of users you expect to enqueue during a reload."
msgstr ""

#: ../../articles/TheArtOfGracefulReloading.rst:101
msgid ""
"To increase the listen queue you use the ``--listen <n>`` option where "
"``<n>`` is the maximum number of slots."
msgstr ""

#: ../../articles/TheArtOfGracefulReloading.rst:104
msgid "To raise kernel limits, you should check your OS docs. Some examples:"
msgstr ""

#: ../../articles/TheArtOfGracefulReloading.rst:106
msgid "sysctl ``kern.ipc.somaxconn`` on FreeBSD"
msgstr ""

#: ../../articles/TheArtOfGracefulReloading.rst:107
msgid "``/proc/sys/net/core/somaxconn`` on Linux."
msgstr ""

#: ../../articles/TheArtOfGracefulReloading.rst:111
msgid ""
"This is only one of the reasons to tune the listen queue, but do not "
"blindly set it to huge values as a way to increase availability."
msgstr ""

#: ../../articles/TheArtOfGracefulReloading.rst:115
msgid "Proxy timeouts"
msgstr ""

#: ../../articles/TheArtOfGracefulReloading.rst:117
msgid ""
"This is another thing you need to check if your reloads take a lot of "
"time."
msgstr ""

#: ../../articles/TheArtOfGracefulReloading.rst:119
msgid "Generally, proxies allow you to set two timeouts:"
msgstr ""

#: ../../articles/TheArtOfGracefulReloading.rst:122
msgid "connect"
msgstr ""

#: ../../articles/TheArtOfGracefulReloading.rst:122
msgid "Maximum amount of time the proxy will wait for a successful connection."
msgstr ""

#: ../../articles/TheArtOfGracefulReloading.rst:126
msgid "read"
msgstr ""

#: ../../articles/TheArtOfGracefulReloading.rst:125
msgid ""
"Maximum amount of time the server will be able to wait for data before "
"giving up."
msgstr ""

#: ../../articles/TheArtOfGracefulReloading.rst:128
msgid ""
"When tuning the reloads, only the \"connection\" timeout matters. This "
"timeout enters the game in the time slice between uWSGI's bind to an "
"interface (or inheritance of it) and the call to ``accept()``."
msgstr ""

#: ../../articles/TheArtOfGracefulReloading.rst:133
msgid "Waiting instead of errors is good, no errors and no waiting is even better"
msgstr ""

#: ../../articles/TheArtOfGracefulReloading.rst:135
msgid ""
"This is the focus of this article. We have seen how to increase the "
"tolerance of your proxy during application server reloading. The "
"customers will wait instead of getting scary errors, but we all want to "
"make money, so why force them to wait?"
msgstr ""

#: ../../articles/TheArtOfGracefulReloading.rst:140
msgid "*We want zero-downtime and zero-wait.*"
msgstr ""

#: ../../articles/TheArtOfGracefulReloading.rst:143
msgid "Preforking VS lazy-apps VS lazy"
msgstr ""

#: ../../articles/TheArtOfGracefulReloading.rst:145
msgid "This is one of the controversial choices of the uWSGI project."
msgstr ""

#: ../../articles/TheArtOfGracefulReloading.rst:147
msgid ""
"By default uWSGI loads the whole application in the first process and "
"after the app is loaded it does ``fork()`` itself multiple times. This is"
" the common Unix pattern, it may highly reduce the memory usage of your "
"app, allows lot of funny tricks and on some languages may bring you a lot"
" of headaches."
msgstr ""

#: ../../articles/TheArtOfGracefulReloading.rst:153
msgid ""
"Albeit its name, uWSGI was born as a Perl application server (it was not "
"called uWSGI and it was not open source), and in the Perl world "
"preforking is generally the blessed way."
msgstr ""

#: ../../articles/TheArtOfGracefulReloading.rst:157
msgid ""
"This is not true for a lot of other languages, platforms and frameworks, "
"so before starting dealing with uWSGI you should choose how to manage "
"``fork()`` in your stack."
msgstr ""

#: ../../articles/TheArtOfGracefulReloading.rst:161
msgid ""
"Seeing it from the \"graceful reloading\" point of view, preforking "
"extremely speeds up things: your app is loaded only one time, and "
"spawning additional workers will be really fast. Avoiding disk access for"
" each worker of your stack will decrease startup times, especially for "
"frameworks or languages doing a lot of disk access to find modules."
msgstr ""

#: ../../articles/TheArtOfGracefulReloading.rst:167
msgid ""
"Unfortunately, the preforking approach forces you to reload the whole "
"stack whenever you make code changes instead of reloading only the "
"workers."
msgstr ""

#: ../../articles/TheArtOfGracefulReloading.rst:170
msgid ""
"In addition to this, your app could need preforking, or could completely "
"crash due to it because of the way it has been developed."
msgstr ""

#: ../../articles/TheArtOfGracefulReloading.rst:173
msgid ""
"lazy-apps mode instead loads your application one time per worker. It "
"will require about O(n) time to load it (where n is the number of "
"workers), will very probably consume more memory, but will run in a more "
"consistent and clean environment."
msgstr ""

#: ../../articles/TheArtOfGracefulReloading.rst:178
msgid ""
"Remember: lazy-apps is different from lazy, the first one only instructs "
"uWSGI to load the application one time per worker, while the second is "
"more invasive (and generally discouraged) as it changes a lot of internal"
" defaults."
msgstr ""

#: ../../articles/TheArtOfGracefulReloading.rst:183
msgid ""
"The following approaches will show you how to accomplish zero-"
"downtime/wait reloads in both preforking and lazy modes."
msgstr ""

#: ../../articles/TheArtOfGracefulReloading.rst:188
msgid "Each approach has pros and cons, choose carefully."
msgstr ""

#: ../../articles/TheArtOfGracefulReloading.rst:191
msgid "Standard (default/boring) graceful reload (aka ``SIGHUP``)"
msgstr ""

#: ../../articles/TheArtOfGracefulReloading.rst:193
msgid "To trigger it, you can:"
msgstr ""

#: ../../articles/TheArtOfGracefulReloading.rst:195
msgid "send ``SIGHUP`` to the master"
msgstr ""

#: ../../articles/TheArtOfGracefulReloading.rst:196
msgid "write ``r`` to :doc:`../MasterFIFO`"
msgstr ""

#: ../../articles/TheArtOfGracefulReloading.rst:197
msgid "use ``--touch-reload`` option"
msgstr ""

#: ../../articles/TheArtOfGracefulReloading.rst:198
msgid "call ``uwsgi.reload()`` API."
msgstr ""

#: ../../articles/TheArtOfGracefulReloading.rst:200
msgid "In preforking and lazy-apps mode, it will:"
msgstr ""

#: ../../articles/TheArtOfGracefulReloading.rst:202
#: ../../articles/TheArtOfGracefulReloading.rst:208
msgid "Wait for running workers."
msgstr ""

#: ../../articles/TheArtOfGracefulReloading.rst:203
msgid "Close all of the file descriptors except the ones mapped to sockets."
msgstr ""

#: ../../articles/TheArtOfGracefulReloading.rst:204
msgid "Call ``exec()`` on itself."
msgstr ""

#: ../../articles/TheArtOfGracefulReloading.rst:206
msgid "In lazy mode, it will:"
msgstr ""

#: ../../articles/TheArtOfGracefulReloading.rst:209
msgid ""
"Restart all of them (this means you cannot change uWSGI options during "
"this kind of reload)."
msgstr ""

#: ../../articles/TheArtOfGracefulReloading.rst:214
msgid "lazy is discouraged!"
msgstr ""

#: ../../articles/TheArtOfGracefulReloading.rst:216
#: ../../articles/TheArtOfGracefulReloading.rst:242
#: ../../articles/TheArtOfGracefulReloading.rst:266
#: ../../articles/TheArtOfGracefulReloading.rst:327
#: ../../articles/TheArtOfGracefulReloading.rst:456
#: ../../articles/TheArtOfGracefulReloading.rst:475
#: ../../articles/TheArtOfGracefulReloading.rst:506
#: ../../articles/TheArtOfGracefulReloading.rst:545
msgid "Pros:"
msgstr ""

#: ../../articles/TheArtOfGracefulReloading.rst:218
msgid "easy to manage"
msgstr ""

#: ../../articles/TheArtOfGracefulReloading.rst:219
msgid "no corner-case problems"
msgstr ""

#: ../../articles/TheArtOfGracefulReloading.rst:220
msgid "no inconsistent states"
msgstr ""

#: ../../articles/TheArtOfGracefulReloading.rst:221
msgid "basically full reset of the instance."
msgstr ""

#: ../../articles/TheArtOfGracefulReloading.rst:223
#: ../../articles/TheArtOfGracefulReloading.rst:246
#: ../../articles/TheArtOfGracefulReloading.rst:272
#: ../../articles/TheArtOfGracefulReloading.rst:332
#: ../../articles/TheArtOfGracefulReloading.rst:460
#: ../../articles/TheArtOfGracefulReloading.rst:479
#: ../../articles/TheArtOfGracefulReloading.rst:511
#: ../../articles/TheArtOfGracefulReloading.rst:550
msgid "Cons:"
msgstr ""

#: ../../articles/TheArtOfGracefulReloading.rst:225
msgid "the ones we seen before"
msgstr ""

#: ../../articles/TheArtOfGracefulReloading.rst:226
msgid "listen queue filling up"
msgstr ""

#: ../../articles/TheArtOfGracefulReloading.rst:227
msgid "stuck workers"
msgstr ""

#: ../../articles/TheArtOfGracefulReloading.rst:228
msgid "potentially long waiting times."
msgstr ""

#: ../../articles/TheArtOfGracefulReloading.rst:231
msgid "Workers reloading in lazy-apps mode"
msgstr ""

#: ../../articles/TheArtOfGracefulReloading.rst:233
#: ../../articles/TheArtOfGracefulReloading.rst:255
msgid "Requires ``--lazy-apps`` option."
msgstr ""

#: ../../articles/TheArtOfGracefulReloading.rst:235
#: ../../articles/TheArtOfGracefulReloading.rst:257
msgid "To trigger it:"
msgstr ""

#: ../../articles/TheArtOfGracefulReloading.rst:237
msgid "write ``w`` to :doc:`../MasterFIFO`"
msgstr ""

#: ../../articles/TheArtOfGracefulReloading.rst:238
msgid "use ``--touch-workers-reload`` option."
msgstr ""

#: ../../articles/TheArtOfGracefulReloading.rst:240
msgid "It will wait for running workers and then restart each of them."
msgstr ""

#: ../../articles/TheArtOfGracefulReloading.rst:244
msgid "avoids restarting the whole instance."
msgstr ""

#: ../../articles/TheArtOfGracefulReloading.rst:248
msgid ""
"no user-experience improvements over standard graceful reload, it is only"
" a shortcut for situation when code updates do not imply instance "
"reconfiguration."
msgstr ""

#: ../../articles/TheArtOfGracefulReloading.rst:253
msgid "Chain reloading (lazy apps)"
msgstr ""

#: ../../articles/TheArtOfGracefulReloading.rst:259
msgid "write ``c`` to :doc:`../MasterFIFO`"
msgstr ""

#: ../../articles/TheArtOfGracefulReloading.rst:260
msgid "use ``--touch-chain-reload`` option."
msgstr ""

#: ../../articles/TheArtOfGracefulReloading.rst:262
msgid ""
"This is the first approach that improves user experience. When triggered,"
" it will restart one worker at time, and the following worker is not "
"reloaded until the previous one is ready to accept new requests."
msgstr ""

#: ../../articles/TheArtOfGracefulReloading.rst:268
msgid "potentially highly reduces waiting time for clients"
msgstr ""

#: ../../articles/TheArtOfGracefulReloading.rst:269
msgid ""
"reduces the load of the machine during reloads (no multiple processes "
"loading the same code)."
msgstr ""

#: ../../articles/TheArtOfGracefulReloading.rst:274
msgid "only useful for code updates"
msgstr ""

#: ../../articles/TheArtOfGracefulReloading.rst:275
msgid "you need a good amount of workers to get a better user experience."
msgstr ""

#: ../../articles/TheArtOfGracefulReloading.rst:278
msgid "Zerg mode"
msgstr ""

#: ../../articles/TheArtOfGracefulReloading.rst:280
msgid "Requires a zerg server or a zerg pool."
msgstr ""

#: ../../articles/TheArtOfGracefulReloading.rst:282
msgid "To trigger it, run the instance in zerg mode."
msgstr ""

#: ../../articles/TheArtOfGracefulReloading.rst:284
msgid ""
"This is the first approach that uses multiple instances of the same "
"application to increase user experience."
msgstr ""

#: ../../articles/TheArtOfGracefulReloading.rst:287
msgid ""
"Zerg mode works by making use of the venerable \"fd passing over Unix "
"sockets\" technique."
msgstr ""

#: ../../articles/TheArtOfGracefulReloading.rst:290
msgid ""
"Basically, an external process (the zerg server/pool) binds to the "
"various sockets required by your app. Your uWSGI instance, instead of "
"binding by itself, asks the zerg server/pool to pass it the file "
"descriptor. This means multiple unrelated instances can ask for the same "
"file descriptors and work together."
msgstr ""

#: ../../articles/TheArtOfGracefulReloading.rst:296
msgid ""
"Zerg mode was born to improve auto-scalability, but soon became one of "
"the most loved approaches for zero-downtime reloading."
msgstr ""

#: ../../articles/TheArtOfGracefulReloading.rst:299
msgid "Now, examples."
msgstr ""

#: ../../articles/TheArtOfGracefulReloading.rst:301
msgid ""
"Spawn a zerg pool exposing ``127.0.0.1:3031`` to the Unix socket "
"``/var/run/pool1``:"
msgstr ""

#: ../../articles/TheArtOfGracefulReloading.rst:310
msgid "Now spawn one or more instances attached to the zerg pool:"
msgstr ""

#: ../../articles/TheArtOfGracefulReloading.rst:318
msgid ""
"When you want to make update of code or options, just spawn a new "
"instance attached to the zerg, and shut down the old one when the new one"
" is ready to accept requests."
msgstr ""

#: ../../articles/TheArtOfGracefulReloading.rst:322
msgid ""
"The so-called \"zerg dance\" is a trick for automation of this kind of "
"reload. There are various ways to accomplish it, the objective is to "
"automatically \"pause\" or \"destroy\" the old instance when the new one "
"is fully ready and able to accept requests. More on this below."
msgstr ""

#: ../../articles/TheArtOfGracefulReloading.rst:329
msgid "potentially the silver bullet"
msgstr ""

#: ../../articles/TheArtOfGracefulReloading.rst:330
msgid "allows instances with different options to cooperate for the same app."
msgstr ""

#: ../../articles/TheArtOfGracefulReloading.rst:334
msgid "requires an additional process"
msgstr ""

#: ../../articles/TheArtOfGracefulReloading.rst:335
msgid "can be hard to master"
msgstr ""

#: ../../articles/TheArtOfGracefulReloading.rst:336
msgid "reload requires copy of the whole uWSGI stack."
msgstr ""

#: ../../articles/TheArtOfGracefulReloading.rst:339
msgid "The Zerg Dance: Pausing instances"
msgstr ""

#: ../../articles/TheArtOfGracefulReloading.rst:341
msgid ""
"We all make mistakes, sysadmins must improve their skill of fast disaster"
" recovery. Focusing on avoiding them is a waste of time. Unfortunately, "
"we are all humans."
msgstr ""

#: ../../articles/TheArtOfGracefulReloading.rst:345
msgid "Rolling back deployments could be your life-safer."
msgstr ""

#: ../../articles/TheArtOfGracefulReloading.rst:347
msgid ""
"We have seen how zerg mode allows us to have multiple instances asking on"
" the same socket. In the previous section we used it to spawn a new "
"instance working together with the old one. Now, instead of shutting down"
" the old instance, why not \"pause\" it? A paused instance is like the "
"standby mode of your TV. It consumes very few resources, but you can "
"bring it back very quickly."
msgstr ""

#: ../../articles/TheArtOfGracefulReloading.rst:354
msgid ""
"\"Zerg Dance\" is the battle-name for the procedure of continuous "
"swapping of instances during reloads. Every reload results in a "
"\"sleeping\" instance and a running one. Following reloads destroy the "
"old sleeping instance and transform the old running to the sleeping one "
"and so on."
msgstr ""

#: ../../articles/TheArtOfGracefulReloading.rst:359
msgid ""
"There are literally dozens of ways to accomplish the \"Zerg Dance\", the "
"fact that you can easily use scripts in your reloading procedures makes "
"this approach extremely powerful and customizable."
msgstr ""

#: ../../articles/TheArtOfGracefulReloading.rst:363
msgid ""
"Here we will see the one that requires zero scripting, it could be the "
"less versatile (and requires at least uWSGI 1.9.21), but should be a good"
" starting point for the improvements."
msgstr ""

#: ../../articles/TheArtOfGracefulReloading.rst:367
msgid ""
":doc:`../MasterFIFO` is the best way to manage instances instead of "
"relying on Unix signals. Basically, you write single-char commands to "
"govern the instance."
msgstr ""

#: ../../articles/TheArtOfGracefulReloading.rst:371
msgid ""
"The funny thing about the Master FIFOs is that you can have many of them "
"configured for your instance and swap one with another very easily."
msgstr ""

#: ../../articles/TheArtOfGracefulReloading.rst:374
msgid "An example will clarify things."
msgstr ""

#: ../../articles/TheArtOfGracefulReloading.rst:376
msgid ""
"We spawn an instance with 3 Master FIFOs: new (the default one), running "
"and sleeping:"
msgstr ""

#: ../../articles/TheArtOfGracefulReloading.rst:392
msgid ""
"By default the \"new\" one will be active (read: will be able to process "
"commands)."
msgstr ""

#: ../../articles/TheArtOfGracefulReloading.rst:395
msgid ""
"Now we want to spawn a new instance, that once is ready to accept "
"requests will put the old one in sleeping mode. To do it, we will use "
"uWSGI's advanced hooks. Hooks allow you to \"make things\" at various "
"phases of uWSGI's life cycle. When the new instance is ready, we want to "
"force the old instance to start working on the sleeping FIFO and be in "
"\"pause\" mode:"
msgstr ""

#: ../../articles/TheArtOfGracefulReloading.rst:426
msgid ""
"The ``hook-accepting1-once`` phase is run one time per instance soon "
"after the first worker is ready to accept requests. The ``writefifo`` "
"command allows writing to FIFOs  without failing if the other peers are "
"not connected (this is different from a simple ``write`` command that "
"would fail or completely block when dealing with bad FIFOs)."
msgstr ""

#: ../../articles/TheArtOfGracefulReloading.rst:434
msgid ""
"Both features have been added only in uWSGI 1.9.21, with older releases "
"you can use the ``--hook-post-app`` option instead of ``--hook-"
"accepting1-once``, but you will lose the \"once\" feature, so it will "
"work reliably only in preforking mode."
msgstr ""

#: ../../articles/TheArtOfGracefulReloading.rst:439
msgid ""
"Instead of ``writefifo`` you can use the shell variant: ``exec:echo "
"<string> > <fifo>``."
msgstr ""

#: ../../articles/TheArtOfGracefulReloading.rst:442
msgid ""
"Now start running instances with the same config files over and over "
"again. If all goes well, you should always end with two instances, one "
"sleeping and one running."
msgstr ""

#: ../../articles/TheArtOfGracefulReloading.rst:446
msgid "Finally, if you want to bring back a sleeping instance, just do:"
msgstr ""

#: ../../articles/TheArtOfGracefulReloading.rst:458
msgid "truly zero-downtime reload."
msgstr ""

#: ../../articles/TheArtOfGracefulReloading.rst:462
msgid "requires high-level uWSGI and Unix skills."
msgstr ""

#: ../../articles/TheArtOfGracefulReloading.rst:465
msgid "``SO_REUSEPORT`` (Linux >= 3.9 and BSDs)"
msgstr ""

#: ../../articles/TheArtOfGracefulReloading.rst:467
msgid ""
"On recent Linux kernels and modern BSDs you may try ``--reuse-port`` "
"option. This option allows multiple unrelated instances to bind on the "
"same network address. You may see it as a kernel-level zerg mode. "
"Basically, all of the Zerg approaches can be followed."
msgstr ""

#: ../../articles/TheArtOfGracefulReloading.rst:472
msgid ""
"Once you add ``--reuse-port`` to you instance, all of the sockets will "
"have the ``SO_REUSEPORT`` flag set."
msgstr ""

#: ../../articles/TheArtOfGracefulReloading.rst:477
msgid "similar to zerg mode, could be even easier to manage."
msgstr ""

#: ../../articles/TheArtOfGracefulReloading.rst:481
msgid "requires kernel support"
msgstr ""

#: ../../articles/TheArtOfGracefulReloading.rst:482
msgid "could lead to inconsistent states"
msgstr ""

#: ../../articles/TheArtOfGracefulReloading.rst:483
msgid ""
"you lose ability to use TCP addresses as a way to avoid incidental "
"multiple instances running."
msgstr ""

#: ../../articles/TheArtOfGracefulReloading.rst:487
msgid "The Black Art (for rich and brave people): master forking"
msgstr ""

#: ../../articles/TheArtOfGracefulReloading.rst:489
msgid "To trigger it, write ``f`` to :doc:`../MasterFIFO`."
msgstr ""

#: ../../articles/TheArtOfGracefulReloading.rst:491
msgid ""
"This is the most dangerous of the ways to reload, but once mastered, it "
"could lead to pretty cool results."
msgstr ""

#: ../../articles/TheArtOfGracefulReloading.rst:494
msgid ""
"The approach is: call ``fork()`` in the master, close all of the file "
"descriptors except the socket-related ones, and ``exec()`` a new uWSGI "
"instance."
msgstr ""

#: ../../articles/TheArtOfGracefulReloading.rst:498
msgid ""
"You will end with two specular uWSGI instances working on the same set of"
" sockets."
msgstr ""

#: ../../articles/TheArtOfGracefulReloading.rst:501
msgid ""
"The scary thing about it is how easy (just write a single char to the "
"master FIFO) is to trigger it..."
msgstr ""

#: ../../articles/TheArtOfGracefulReloading.rst:504
msgid "With a bit of mastery you can implement the zerg dance on top of it."
msgstr ""

#: ../../articles/TheArtOfGracefulReloading.rst:508
msgid "does not require kernel support nor an additional process"
msgstr ""

#: ../../articles/TheArtOfGracefulReloading.rst:509
msgid "pretty fast."
msgstr ""

#: ../../articles/TheArtOfGracefulReloading.rst:513
msgid "a whole copy for each reload"
msgstr ""

#: ../../articles/TheArtOfGracefulReloading.rst:514
msgid ""
"inconstent states all over the place (pidfiles, logging, etc.: the master"
" FIFO commands could help fix them)."
msgstr ""

#: ../../articles/TheArtOfGracefulReloading.rst:518
msgid "Subscription system"
msgstr ""

#: ../../articles/TheArtOfGracefulReloading.rst:520
msgid ""
"This is probably the best approach when you can count on multiple "
"servers. You add the \"fastrouter\" between your proxy server (e.g., "
"nginx) and your instances."
msgstr ""

#: ../../articles/TheArtOfGracefulReloading.rst:524
msgid ""
"Instances will \"subscribe\" to the fastrouter that will pass requests "
"from proxy server (nginx) to them while load balancing and constantly "
"monitoring all of them."
msgstr ""

#: ../../articles/TheArtOfGracefulReloading.rst:528
msgid ""
"Subscriptions are simple UDP packets that instruct the fastrouter which "
"domain maps to which instance or instances."
msgstr ""

#: ../../articles/TheArtOfGracefulReloading.rst:531
msgid ""
"As you can subscribe, you can unsubscribe too, and this is where the "
"magic happens:"
msgstr ""

#: ../../articles/TheArtOfGracefulReloading.rst:541
msgid ""
"Adding ``unsubscribe-on-graceful-reload`` will force the instance to send"
" an \"unsubscribe\" packet to the fastrouter, so until it will not be "
"back no request will be sent to it."
msgstr ""

#: ../../articles/TheArtOfGracefulReloading.rst:547
msgid "low-cost zero-downtime"
msgstr ""

#: ../../articles/TheArtOfGracefulReloading.rst:548
msgid "a KISS approach (*finally*)."
msgstr ""

#: ../../articles/TheArtOfGracefulReloading.rst:552
msgid ""
"requires a subscription server (like the fastrouter) that introduces "
"overhead (even if we are talking about microseconds)."
msgstr ""

#: ../../articles/TheArtOfGracefulReloading.rst:556
msgid "Inconsistent states"
msgstr ""

#: ../../articles/TheArtOfGracefulReloading.rst:558
msgid ""
"Sadly, most of the approaches involving copies of the whole instance "
"(like Zerg Dance or master forking) lead to inconsistent states."
msgstr ""

#: ../../articles/TheArtOfGracefulReloading.rst:561
msgid ""
"Take, for example, an instance writing pidfiles: when starting a copy of "
"it, that pidfile will be overwritten."
msgstr ""

#: ../../articles/TheArtOfGracefulReloading.rst:564
msgid ""
"If you carefully plan your configurations, you can avoid inconsistent "
"states, but thanks to :doc:`../MasterFIFO` you can manage some of them "
"(read: the most common ones):"
msgstr ""

#: ../../articles/TheArtOfGracefulReloading.rst:568
msgid "``l`` command will reopen logfiles"
msgstr ""

#: ../../articles/TheArtOfGracefulReloading.rst:569
msgid "``P`` command will update all of the instance pidfiles."
msgstr ""

#: ../../articles/TheArtOfGracefulReloading.rst:572
msgid "Fighting inconsistent states with the Emperor"
msgstr ""

#: ../../articles/TheArtOfGracefulReloading.rst:574
msgid ""
"If you manage your instances with the :doc:`Emperor<../Emperor>`, you can"
" use its features to avoid (or reduce number of) inconsistent states."
msgstr ""

#: ../../articles/TheArtOfGracefulReloading.rst:577
msgid ""
"Giving each instance a different symbolic link name will allow you to map"
" files (like pidfiles or logs) to different paths:"
msgstr ""

#: ../../articles/TheArtOfGracefulReloading.rst:587
msgid ""
"The ``safe-pidfile`` option works similar to ``pidfile`` but performs the"
" write a little later in the loading process. This avoids overwriting the"
" value when app loading fails, with the consequent loss of a valid PID "
"number."
msgstr ""

#: ../../articles/TheArtOfGracefulReloading.rst:592
msgid "Dealing with ultra-lazy apps (like Django)"
msgstr ""

#: ../../articles/TheArtOfGracefulReloading.rst:594
msgid ""
"Some applications or frameworks (like Django) may load the vast majority "
"of their code only at the first request. This means that customer will "
"continue to experience slowdowns during reload even when using things "
"like zerg mode or similar."
msgstr ""

#: ../../articles/TheArtOfGracefulReloading.rst:599
msgid ""
"This problem is hard to solve (impossible?) in the application server "
"itself, so you should find a way to force your app to load itself ASAP. A"
" good trick (read: works with Django) is to call the entry-point function"
" (like the WSGI callable) in the app itself:"
msgstr ""

#: ../../articles/TheArtOfGracefulReloading.rst:612
msgid ""
"You may need to pass CGI vars to the environ to make a true request: it "
"depends on the WSGI app."
msgstr ""

#: ../../articles/TheArtOfGracefulReloading.rst:616
msgid "Finally: Do not blindly copy & paste!"
msgstr ""

#: ../../articles/TheArtOfGracefulReloading.rst:618
msgid ""
"Please, turn on your brain and try to adapt shown configs to your needs, "
"or invent new ones."
msgstr ""

#: ../../articles/TheArtOfGracefulReloading.rst:621
msgid "Each app and system is different from the others."
msgstr ""

#: ../../articles/TheArtOfGracefulReloading.rst:623
msgid "Experiment before making a choice."
msgstr ""

#: ../../articles/TheArtOfGracefulReloading.rst:626
msgid "References"
msgstr ""

#: ../../articles/TheArtOfGracefulReloading.rst:628
msgid ":doc:`../MasterFIFO`"
msgstr ""

#: ../../articles/TheArtOfGracefulReloading.rst:630
msgid ":doc:`../Hooks`"
msgstr ""

#: ../../articles/TheArtOfGracefulReloading.rst:632
msgid ":doc:`../Zerg`"
msgstr ""

#: ../../articles/TheArtOfGracefulReloading.rst:634
msgid ":doc:`../Fastrouter`"
msgstr ""

#: ../../articles/TheArtOfGracefulReloading.rst:636
msgid ":doc:`../SubscriptionServer`"
msgstr ""

