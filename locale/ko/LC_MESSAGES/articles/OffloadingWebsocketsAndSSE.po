# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2012-2016, uWSGI
# This file is distributed under the same license as the uWSGI package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2019.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: uWSGI 2.0\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2019-05-09 10:15+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.6.0\n"

#: ../../articles/OffloadingWebsocketsAndSSE.rst:2
msgid ""
"Offloading Websockets and Server-Sent Events AKA \"Combine them with "
"Django safely\""
msgstr ""

#: ../../articles/OffloadingWebsocketsAndSSE.rst:4
msgid "Author: Roberto De Ioris"
msgstr ""

#: ../../articles/OffloadingWebsocketsAndSSE.rst:6
msgid "Date: 20140315"
msgstr ""

#: ../../articles/OffloadingWebsocketsAndSSE.rst:9
msgid "Disclaimer"
msgstr ""

#: ../../articles/OffloadingWebsocketsAndSSE.rst:11
msgid ""
"This article shows a pretty advanced way for combining websockets (or "
"sse) apps with Django in a \"safe way\". It will not show you how cool "
"websockets and sse are, or how to write better apps with them, it is an "
"attempt to try to avoid bad practices with them."
msgstr ""

#: ../../articles/OffloadingWebsocketsAndSSE.rst:14
msgid ""
"In my opinion the Python web-oriented world is facing a "
"communication/marketing problem: There is a huge number of people running"
" heavily blocking apps (like Django) on non-blocking technologies (like "
"gevent) only because someone told them it is cool and will solve all of "
"their scaling issues."
msgstr ""

#: ../../articles/OffloadingWebsocketsAndSSE.rst:17
msgid ""
"This is completely WRONG, DANGEROUS and EVIL, you cannot mix blocking "
"apps with non-blocking engines, even a single, ultra-tiny blocking part "
"can potentially destroy your whole stack. As I have already said dozens "
"of time, if your app is 99.9999999% non-blocking, it is still blocking."
msgstr ""

#: ../../articles/OffloadingWebsocketsAndSSE.rst:20
msgid ""
"And no, monkey-patching on your Django app is not magic. Unless you are "
"using pretty-customized database adapters, tuned for working in a non-"
"blocking way, you are doing it wrong."
msgstr ""

#: ../../articles/OffloadingWebsocketsAndSSE.rst:22
msgid ""
"At the cost of looking a huber-asshole, I strongly suggest you completely"
" ignore people suggesting you move your Django app to gevent, eventlet, "
"tornado or whatever, without warning you about the hundreds of problems "
"you may encounter."
msgstr ""

#: ../../articles/OffloadingWebsocketsAndSSE.rst:25
msgid ""
"Having said that, I love gevent, it is probably the best (with perl's "
"Coro::AnyEvent) supported loop engine in the uWSGI project. So in this "
"article I will use gevent for managing websocket/sse traffic and plain "
"multiprocessing for the Django part."
msgstr ""

#: ../../articles/OffloadingWebsocketsAndSSE.rst:27
msgid ""
"If this last sentence looks like nonsense to you, you probably do not "
"know what uWSGI offloading is..."
msgstr ""

#: ../../articles/OffloadingWebsocketsAndSSE.rst:31
msgid "uWSGI offloading"
msgstr ""

#: ../../articles/OffloadingWebsocketsAndSSE.rst:33
msgid ""
"The concept is not a new thing, or a uWSGI specific one. Projects like "
"nodejs or twisted have used it for ages."
msgstr ""

#: ../../articles/OffloadingWebsocketsAndSSE.rst:35
msgid ""
"an example of a webapp serving a static file is not very interesting, nor"
" the best thing to show, but will be useful later, when presenting a "
"real-world scenario with X-Sendfile"
msgstr ""

#: ../../articles/OffloadingWebsocketsAndSSE.rst:37
msgid "Immagine this simple WSGI app:"
msgstr ""

#: ../../articles/OffloadingWebsocketsAndSSE.rst:47
msgid ""
"This will simply return the content of /etc/services. It is a pretty tiny"
" file, so in few milliseconds your process will be ready to process "
"another request."
msgstr ""

#: ../../articles/OffloadingWebsocketsAndSSE.rst:49
msgid ""
"What if /etc/services is 4 gigabytes? Your process (or thread) will be "
"blocked for several seconds (even minutes), and will not be able to "
"manage another request until the file is completely transferred."
msgstr ""

#: ../../articles/OffloadingWebsocketsAndSSE.rst:52
msgid ""
"Wouldn't it be cool if you could tell another thread to send the file for"
" you, so you will be able to manage another request?"
msgstr ""

#: ../../articles/OffloadingWebsocketsAndSSE.rst:54
msgid ""
"Offloading is exactly this: it will give you one ore more threads for "
"doing simple and slow task for you. Which kind of tasks? All of those "
"that can be managed in a non-blocking way, so a single thread can manage "
"thousand of transfers for you."
msgstr ""

#: ../../articles/OffloadingWebsocketsAndSSE.rst:57
msgid ""
"You can see it as the DMA engine in your computer, your CPU will program "
"the DMA to transfer memory from a controller to the RAM, and then will be"
" freed to accomplish another task while the DMA works in background."
msgstr ""

#: ../../articles/OffloadingWebsocketsAndSSE.rst:59
msgid ""
"To enable offloading in uWSGI you only need to add the ``--offload-"
"threads <n>`` option, where <n> is the number of threads per-process to "
"spawn. (generally a single thread will be more than enough, but if you "
"want to use/abuse your multiple cpu cores feel free to increase it)"
msgstr ""

#: ../../articles/OffloadingWebsocketsAndSSE.rst:61
msgid ""
"Once offloading is enabled, uWSGI will automatically use it whenever it "
"detects that an operation can be offloaded safely."
msgstr ""

#: ../../articles/OffloadingWebsocketsAndSSE.rst:63
msgid ""
"In the python/WSGI case any use of wsgi.file_wrapper will be offloaded "
"automatically, as well as when you use the uWSGI proxy features for "
"passing requests to other server speaking the uwsgi or HTTP protocol."
msgstr ""

#: ../../articles/OffloadingWebsocketsAndSSE.rst:65
msgid ""
"A cool example (showed even in the Snippets page of uWSGI docs) is "
"implementing an offload-powered X-Sendfile feature:"
msgstr ""

#: ../../articles/OffloadingWebsocketsAndSSE.rst:93
msgid "Now in our app we can X-Sendfile to send static files without blocking:"
msgstr ""

#: ../../articles/OffloadingWebsocketsAndSSE.rst:102
msgid ""
"A very similar concept will be used in this article: We will use a normal"
" Django to setup our session, to authorize the user and whatever (that is"
" fast) you want, then we will return a special header that will instruct "
"uWSGI to offload the connection to another uWSGI instance (listening on a"
" private socket) that will manage the websocket/sse transaction using "
"gevent in a non-blocking way."
msgstr ""

#: ../../articles/OffloadingWebsocketsAndSSE.rst:105
msgid "Our SSE app"
msgstr ""

#: ../../articles/OffloadingWebsocketsAndSSE.rst:107
msgid ""
"The SSE part will be very simple, a gevent-based WSGI app will send the "
"current time every second:"
msgstr ""

#: ../../articles/OffloadingWebsocketsAndSSE.rst:132
msgid "Let's run it on /tmp/foo UNIX socket (save the app as sseapp.py)"
msgstr ""

#: ../../articles/OffloadingWebsocketsAndSSE.rst:138
msgid ""
"(monkey patching is required for time.sleep(), feel free to use gevent "
"primitives for sleeping if you want/prefer)"
msgstr ""

#: ../../articles/OffloadingWebsocketsAndSSE.rst:141
msgid "The (boring) HTML/Javascript"
msgstr ""

#: ../../articles/OffloadingWebsocketsAndSSE.rst:165
msgid ""
"It is very simple, it will connect to /subscribe and will start waiting "
"for events."
msgstr ""

#: ../../articles/OffloadingWebsocketsAndSSE.rst:168
msgid "The Django view"
msgstr ""

#: ../../articles/OffloadingWebsocketsAndSSE.rst:170
msgid ""
"Our django view, will be very simple, it will simply generate a special "
"response header (we will call it X-Offload-to-SSE) with the username of "
"the logged user as its value:"
msgstr ""

#: ../../articles/OffloadingWebsocketsAndSSE.rst:179
msgid "Now we are ready for the \"advanced\" part."
msgstr ""

#: ../../articles/OffloadingWebsocketsAndSSE.rst:183
msgid "Let's offload the SSE transaction"
msgstr ""

#: ../../articles/OffloadingWebsocketsAndSSE.rst:185
msgid ""
"The configuration could look a bit complex but it is the same concept of "
"the X-Sendfile seen before:"
msgstr ""

#: ../../articles/OffloadingWebsocketsAndSSE.rst:202
msgid ""
"The only \"new' part is the use of ``disableheaders`` routing action. It "
"is required otherwise the headers generated by Django will be sent along "
"the ones generated by the gevent-based app."
msgstr ""

#: ../../articles/OffloadingWebsocketsAndSSE.rst:205
msgid ""
"You could avoid it (remember that ``disableheaders`` has been added only "
"in 2.0.3) removing the call to start_response() in the gevent app (at the"
" risk of being cursed by some WSGI-god) and changing the Django view to "
"set the right headers:"
msgstr ""

#: ../../articles/OffloadingWebsocketsAndSSE.rst:216
msgid ""
"Eventually you may want to be more \"streamlined\" and simply detect for "
"'text/event-stream' content_type presence:"
msgstr ""

#: ../../articles/OffloadingWebsocketsAndSSE.rst:232
msgid ""
"Now, how to access the username of the Django-logged user in the gevent "
"app?"
msgstr ""

#: ../../articles/OffloadingWebsocketsAndSSE.rst:234
msgid ""
"You should have noted that the gevent-app prints the content of the WSGI "
"environ on each request. That environment is the same of the Django app +"
" the collected headers. So accessing environ['X_OFFLOAD'] will return the"
" logged username. (obviously in the second example, where the content "
"type is used, the variable with the username is no longer collected, so "
"you should fix it)"
msgstr ""

#: ../../articles/OffloadingWebsocketsAndSSE.rst:237
msgid ""
"You can pass all of the information you need using the same approach, you"
" can collect all of the vars you need and so on."
msgstr ""

#: ../../articles/OffloadingWebsocketsAndSSE.rst:239
msgid "You can even add variables at runtime:"
msgstr ""

#: ../../articles/OffloadingWebsocketsAndSSE.rst:259
msgid "Or (using goto for better readability):"
msgstr ""

#: ../../articles/OffloadingWebsocketsAndSSE.rst:282
msgid "Simplifying things using the uwsgi api (>= uWSGI 2.0.3)"
msgstr ""

#: ../../articles/OffloadingWebsocketsAndSSE.rst:284
msgid ""
"While dealing with headers is pretty HTTP friendly, uWSGI 2.0.3 added the"
" possibility to define per-request variables directly in your code."
msgstr ""

#: ../../articles/OffloadingWebsocketsAndSSE.rst:287
msgid "This allows a more \"elegant\" approach (even if highly non-portable):"
msgstr ""

#: ../../articles/OffloadingWebsocketsAndSSE.rst:300
msgid "Now the config can change to something more gentle:"
msgstr ""

#: ../../articles/OffloadingWebsocketsAndSSE.rst:314
msgid ""
"Have you noted how we allowed the Django app to set the backend server to"
" use using a request variable?"
msgstr ""

#: ../../articles/OffloadingWebsocketsAndSSE.rst:316
msgid ""
"Now we can go even further. We will not use the routing framework (except"
" for disabling headers generation):"
msgstr ""

#: ../../articles/OffloadingWebsocketsAndSSE.rst:328
msgid "and a simple:"
msgstr ""

#: ../../articles/OffloadingWebsocketsAndSSE.rst:341
msgid "What about Websockets ?"
msgstr ""

#: ../../articles/OffloadingWebsocketsAndSSE.rst:343
msgid ""
"We have seen how to offload SSE (that are mono-directional). We can "
"offload websockets too (that are bidirectional)."
msgstr ""

#: ../../articles/OffloadingWebsocketsAndSSE.rst:345
msgid ""
"The concept is the same, you only need to ensure (as before) that no "
"headers are sent by django, (otherwise the websocket handshake will fail)"
" and then you can change your gevent app:"
msgstr ""

#: ../../articles/OffloadingWebsocketsAndSSE.rst:364
msgid "Using redis or uWSGI caching framework"
msgstr ""

#: ../../articles/OffloadingWebsocketsAndSSE.rst:366
msgid ""
"Request vars are handy (and funny), but they are limited (see below). If "
"you need to pass a big amount of data between Django and the "
"sse/websocket app, Redis is a great way (and works perfectly with "
"gevent). Basically you store infos from django to redis and than you pass"
" only the hash key (via request vars) to the sse/websocket app."
msgstr ""

#: ../../articles/OffloadingWebsocketsAndSSE.rst:369
msgid ""
"The same can be accomplished with the uWSGI caching framework, but take "
"into account redis has a lot of data primitives, while uWSGI only "
"supports key->value items."
msgstr ""

#: ../../articles/OffloadingWebsocketsAndSSE.rst:372
msgid "Common pitfalls"
msgstr ""

#: ../../articles/OffloadingWebsocketsAndSSE.rst:374
msgid ""
"The amount of variables you can add per-request is limited by the uwsgi "
"packet buffer (default 4k). You can increase it up to 64k with the "
"--buffer-size option."
msgstr ""

#: ../../articles/OffloadingWebsocketsAndSSE.rst:376
msgid ""
"This is the whole point of this article: do not use the Django ORM in "
"your gevent apps unless you know what you are doing!!! (read: you have a "
"django database adapter that supports gevent and does not suck compared "
"to the standard ones...)"
msgstr ""

#: ../../articles/OffloadingWebsocketsAndSSE.rst:378
msgid ""
"Forget about finding a way to disable headers generation in django. This "
"is a \"limit/feature\" of its WSGI adapter, use the uWSGI facilities (if "
"available) or do not generate headers in your gevent app. Eventually you "
"can modify wsgi.py in this way:"
msgstr ""

