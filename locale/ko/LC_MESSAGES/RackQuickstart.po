# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2012-2016, uWSGI
# This file is distributed under the same license as the uWSGI package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2019.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: uWSGI 2.0\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2019-05-09 10:15+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.6.0\n"

#: ../../RackQuickstart.rst:2
msgid "Quickstart for ruby/Rack applications"
msgstr ""

#: ../../RackQuickstart.rst:4
msgid ""
"The following instructions will guide you through installing and running "
"a Ruby-based uWSGI distribution aimed at running Rack apps."
msgstr ""

#: ../../RackQuickstart.rst:7
msgid "Installing uWSGI with Ruby support"
msgstr ""

#: ../../RackQuickstart.rst:9
msgid ""
"To build uWSGI you need a C compiler (gcc and clang are supported) and "
"the Python binary (to run the uwsgiconfig.py script that will execute the"
" various compilation steps)."
msgstr ""

#: ../../RackQuickstart.rst:11
msgid ""
"As we are building an uWSGI binary with Ruby support we need the Ruby "
"development headers too (the ``ruby-dev`` package on Debian-based "
"distributions)."
msgstr ""

#: ../../RackQuickstart.rst:13
msgid "You can build uWSGI manually -- all of these are equivalent:"
msgstr ""

#: ../../RackQuickstart.rst:22
msgid ""
"But if you are lazy, you can download, build and install an uWSGI + Ruby "
"binary in a single shot:"
msgstr ""

#: ../../RackQuickstart.rst:28
msgid "Or in a more \"Ruby-friendly\" way:"
msgstr ""

#: ../../RackQuickstart.rst:34
msgid ""
"All of these methods build a \"monolithic\" uWSGI binary. The uWSGI "
"project is composed by dozens of plugins. You can choose to build the "
"server core and having a plugin for every feature (that you will load "
"when needed), or you can build a single binary with all the features you "
"need. This latter kind of build is called 'monolithic'."
msgstr ""

#: ../../RackQuickstart.rst:38
msgid ""
"This quickstart assumes a monolithic binary (so you do not need to load "
"plugins). If you prefer to use your package distributions (instead of "
"building uWSGI from official sources), see below."
msgstr ""

#: ../../RackQuickstart.rst:42
msgid "Note for distro packages"
msgstr ""

#: ../../RackQuickstart.rst:44
msgid ""
"Your distribution very probably contains an uWSGI package set. Those "
"uWSGI packages tend to be highly modular (and occasionally highly "
"outdated), so in addition to the core you need to install the required "
"plugins. Plugins must be loaded in your uWSGI configuration. In the "
"learning phase we strongly suggest to not use distribution packages to "
"easily follow documentation and tutorials."
msgstr ""

#: ../../RackQuickstart.rst:48
msgid ""
"Once you feel comfortable with the \"uWSGI way\" you can choose the best "
"approach for your deployments."
msgstr ""

#: ../../RackQuickstart.rst:50
msgid ""
"As an example, the tutorial makes use of the \"http\" and \"rack\" "
"plugins. If you are using a modular build be sure to load them with the "
"``--plugins http,rack`` option."
msgstr ""

#: ../../RackQuickstart.rst:53
msgid "Your first Rack app"
msgstr ""

#: ../../RackQuickstart.rst:55
msgid "Rack is the standard way for writing Ruby web apps."
msgstr ""

#: ../../RackQuickstart.rst:57
msgid "This is a standard Rack Hello world script (call it app.ru):"
msgstr ""

#: ../../RackQuickstart.rst:71
msgid ""
"The ``.ru`` extension stands for \"rackup\", which is the deployment tool"
" included in the Rack distribution. Rackup uses a little DSL, so to use "
"it into uWSGI you need to install the rack gem:"
msgstr ""

#: ../../RackQuickstart.rst:78
msgid "Now we are ready to deploy with uWSGI:"
msgstr ""

#: ../../RackQuickstart.rst:84
msgid "(remember to replace ‘uwsgi’ if it is not in your current $PATH)"
msgstr ""

#: ../../RackQuickstart.rst:86
msgid "or if you are using a modular build (like the one of your distribution)"
msgstr ""

#: ../../RackQuickstart.rst:92
msgid ""
"With this command line we've spawned an HTTP proxy routing each request "
"to a process (named the 'worker') that manages it and send back the "
"response to the HTTP router (that sends back to the client)."
msgstr ""

#: ../../RackQuickstart.rst:94
msgid ""
"If you are asking yourself why spawning two processes, it is because this"
" is the normal architecture you will use in production (a frontline web "
"server with a backend application server)."
msgstr ""

#: ../../RackQuickstart.rst:96
msgid ""
"If you do not want to spawn the HTTP proxy and directly force the worker "
"to answer HTTP requests just change the command line to"
msgstr ""

#: ../../RackQuickstart.rst:102
msgid ""
"now you have a single process managing requests (but remember that "
"directly exposing the application server to the public is generally "
"dangerous and less versatile)."
msgstr ""

#: ../../RackQuickstart.rst:105
msgid "What is that '--http-modifier1 7' thing?"
msgstr ""

#: ../../RackQuickstart.rst:107
msgid ""
"uWSGI supports various languages and platforms. When the server receives "
"a request it has to know where to 'route' it."
msgstr ""

#: ../../RackQuickstart.rst:109
msgid ""
"Each uWSGI plugin has an assigned number (the modifier), the ruby/rack "
"one has the 7. So ``--http-modifier1 7`` means \"route to the rack "
"plugin\"."
msgstr ""

#: ../../RackQuickstart.rst:111
msgid ""
"Though uWSGI also has a more \"human-friendly\" :doc:`internal routing "
"system <InternalRouting>` using modifiers is the fastest way, so if at "
"all possible always use them."
msgstr ""

#: ../../RackQuickstart.rst:114
msgid "Using a full webserver: nginx"
msgstr ""

#: ../../RackQuickstart.rst:116
msgid ""
"The supplied HTTP router, is (yes, astoundingly enough) only a router. "
"You can use it as a load balancer or a proxy, but if you need a full web "
"server (for efficiently serving static files or all of those task a "
"webserver is good at), you can get rid of the uwsgi HTTP router (remember"
" to change --plugins http,rack to --plugins rack if you are using a "
"modular build) and put your app behind Nginx."
msgstr ""

#: ../../RackQuickstart.rst:120
msgid ""
"To communicate with Nginx, uWSGI can use various protocol: HTTP, uwsgi, "
"FastCGI, SCGI, etc."
msgstr ""

#: ../../RackQuickstart.rst:122
msgid ""
"The most efficient one is the uwsgi one. Nginx includes uwsgi protocol "
"support out of the box."
msgstr ""

#: ../../RackQuickstart.rst:124
msgid "Run your rack application on an uwsgi socket:"
msgstr ""

#: ../../RackQuickstart.rst:130
msgid "then add a location stanza in your nginx config"
msgstr ""

#: ../../RackQuickstart.rst:140
msgid ""
"Reload your nginx server, and it should start proxying requests to your "
"uWSGI instance."
msgstr ""

#: ../../RackQuickstart.rst:142
msgid ""
"Note that you do not need to configure uWSGI to set a specific modifier, "
"nginx will do it using the ``uwsgi_modifier1 5;`` directive."
msgstr ""

#: ../../RackQuickstart.rst:145
msgid "Adding concurrency"
msgstr ""

#: ../../RackQuickstart.rst:147
msgid ""
"With the previous example you deployed a stack being able to serve a "
"single request at time."
msgstr ""

#: ../../RackQuickstart.rst:149
msgid ""
"To increase concurrency you need to add more processes. If you are hoping"
" there is a magic math formula to find the right number of processes to "
"spawn, well... we're sorry. You need to experiment and monitor your app "
"to find the right value. Take in account every single process is a "
"complete copy of your app, so memory usage should be taken in account."
msgstr ""

#: ../../RackQuickstart.rst:154
msgid "To add more processes just use the `--processes <n>` option:"
msgstr ""

#: ../../RackQuickstart.rst:160
msgid "will spawn 8 processes."
msgstr ""

#: ../../RackQuickstart.rst:162
msgid ""
"Ruby 1.9/2.0 introduced an improved threads support and uWSGI supports it"
" via the 'rbthreads' plugin. This plugin is automatically built when you "
"compile the uWSGI+ruby (>=1.9) monolithic binary."
msgstr ""

#: ../../RackQuickstart.rst:165
msgid "To add more threads:"
msgstr ""

#: ../../RackQuickstart.rst:171
msgid "or threads + processes"
msgstr ""

#: ../../RackQuickstart.rst:177
msgid ""
"There are other (generally more advanced/complex) ways to increase "
"concurrency (for example 'fibers'), but most of the time you will end up "
"with a plain old multi-process or multi-thread models. If you are "
"interested, check the complete documentation over at :doc:`Rack`."
msgstr ""

#: ../../RackQuickstart.rst:181
msgid "Adding robustness: the Master process"
msgstr ""

#: ../../RackQuickstart.rst:183
msgid ""
"It is highly recommended to have the uWSGI master process always running "
"on productions apps."
msgstr ""

#: ../../RackQuickstart.rst:185
msgid ""
"It will constantly monitor your processes/threads and will add fun "
"features like the :doc:`StatsServer`."
msgstr ""

#: ../../RackQuickstart.rst:187
msgid "To enable the master simply add ``--master``"
msgstr ""

#: ../../RackQuickstart.rst:194
msgid "Using config files"
msgstr ""

#: ../../RackQuickstart.rst:196
msgid ""
"uWSGI has literally hundreds of options (but generally you will not use "
"more than a dozens of them). Dealing with them via command line is "
"basically silly, so try to always use config files."
msgstr ""

#: ../../RackQuickstart.rst:198
msgid ""
"uWSGI supports various standards (XML, INI, JSON, YAML, etc). Moving from"
" one to another is pretty simple. The same options you can use via "
"command line can be used with config files by simply removing the ``--`` "
"prefix:"
msgstr ""

#: ../../RackQuickstart.rst:209
msgid "or xml:"
msgstr ""

#: ../../RackQuickstart.rst:220
msgid "To run uWSGI using a config file, just specify it as argument:"
msgstr ""

#: ../../RackQuickstart.rst:226
msgid ""
"if for some reason your config cannot end with the expected extension "
"(.ini, .xml, .yml, .js) you can force the binary to use a specific parser"
" in this way:"
msgstr ""

#: ../../RackQuickstart.rst:241
msgid "and so on."
msgstr ""

#: ../../RackQuickstart.rst:243
msgid "You can even pipe configs (using the dash to force reading from stdin):"
msgstr ""

#: ../../RackQuickstart.rst:250
msgid "The fork() problem when you spawn multiple processes"
msgstr ""

#: ../../RackQuickstart.rst:252
msgid ""
"uWSGI is \"Perlish\" in a way, there is nothing we can do to hide that. "
"Most of its choices (starting from \"There's more than one way to do "
"it\") came from the Perl world (and more generally from classical UNIX "
"sysadmin approaches)."
msgstr ""

#: ../../RackQuickstart.rst:254
msgid ""
"Sometimes this approach could lead to unexpected behaviors when applied "
"to other languages/platforms."
msgstr ""

#: ../../RackQuickstart.rst:256
msgid ""
"One of the \"problems\" you can face when starting to learn uWSGI is its "
"``fork()`` usage."
msgstr ""

#: ../../RackQuickstart.rst:258
msgid ""
"By default uWSGI loads your application in the first spawned process and "
"then ``fork()`` itself multiple times."
msgstr ""

#: ../../RackQuickstart.rst:260
msgid "It means your app is loaded a single time and then copied."
msgstr ""

#: ../../RackQuickstart.rst:262
msgid ""
"While this approach speedups the start of the server, some application "
"could have problems with this technique (especially those initializing db"
" connections on startup, as the file descriptor of the connection will be"
" inherited in the subprocesses)."
msgstr ""

#: ../../RackQuickstart.rst:265
msgid ""
"If you are unsure about the brutal preforking used by uWSGI, just disable"
" it with the ``--lazy-apps`` option. It will force uWSGI to completely "
"load your app one time per each worker."
msgstr ""

#: ../../RackQuickstart.rst:269
msgid "Deploying Sinatra"
msgstr ""

#: ../../RackQuickstart.rst:271
msgid ""
"Let's forget about fork(), and back to fun things. This time we're "
"deploying a Sinatra application:"
msgstr ""

#: ../../RackQuickstart.rst:283
msgid "save it as ``config.ru`` and run as seen before:"
msgstr ""

#: ../../RackQuickstart.rst:298
msgid ""
"Well, maybe you already noted that basically nothing changed from the "
"previous app.ru examples."
msgstr ""

#: ../../RackQuickstart.rst:300
msgid ""
"That is because basically every modern Rack app exposes itself as a .ru "
"file (generally called config.ru), so there is no need for multiple "
"options for loading applications (like for example in the Python/WSGI "
"world)."
msgstr ""

#: ../../RackQuickstart.rst:304
msgid "Deploying RubyOnRails >= 3"
msgstr ""

#: ../../RackQuickstart.rst:306
msgid ""
"Starting from 3.0, Rails is fully Rack compliant, and exposes a config.ru"
" file you can directly load (like we did with Sinatra)."
msgstr ""

#: ../../RackQuickstart.rst:308
msgid ""
"The only difference from Sinatra is that your project has a specific "
"layout/convention expecting your current working directory is the one "
"containing the project, so let's add a chdir option:"
msgstr ""

#: ../../RackQuickstart.rst:325
msgid ""
"In addition to chdir we have added the 'env' option that set the "
"``RAILS_ENV`` environment variable."
msgstr ""

#: ../../RackQuickstart.rst:327
msgid "Starting from 4.0, Rails support multiple threads (only for ruby 2.0):"
msgstr ""

#: ../../RackQuickstart.rst:342
msgid "Deploying older RubyOnRails"
msgstr ""

#: ../../RackQuickstart.rst:344
msgid ""
"Older Rails versions are not fully Rack-compliant. For such a reason a "
"specific option is available in uWSGI to load older Rails apps (you will "
"need the 'thin' gem too)."
msgstr ""

#: ../../RackQuickstart.rst:356
msgid ""
"So, in short, specify the ``rails`` option, passing the rails app "
"directory as the argument, instead of a Rackup file."
msgstr ""

#: ../../RackQuickstart.rst:359
msgid "Bundler and RVM"
msgstr ""

#: ../../RackQuickstart.rst:361
msgid ""
"Bundler is the standard de-facto Ruby tool for managing dependencies. "
"Basically you specify the gems needed by your app in the Gemfile text "
"file and then you launch bundler to install them."
msgstr ""

#: ../../RackQuickstart.rst:363
msgid "To allow uWSGI to honor bundler installations you only need to add:"
msgstr ""

#: ../../RackQuickstart.rst:371
msgid "(The first require stanza is not required for ruby 1.9/2.x.)"
msgstr ""

#: ../../RackQuickstart.rst:373
msgid ""
"Basically those lines force uWSGI to load the bundler engine and to use "
"the Gemfile specified in the ``BUNDLE_GEMFILE`` environment variable."
msgstr ""

#: ../../RackQuickstart.rst:375
msgid ""
"When using Bundler (like modern frameworks do) your common deployment "
"configuration will be:"
msgstr ""

#: ../../RackQuickstart.rst:389
msgid "In addition to Bundler, RVM is another common tool."
msgstr ""

#: ../../RackQuickstart.rst:391
msgid ""
"It allows you to have multiple (independent) Ruby installations (with "
"their gemsets) on a single system."
msgstr ""

#: ../../RackQuickstart.rst:393
msgid ""
"To instruct uWSGI to use the gemset of a specific RVM version just use "
"the `--gemset` option:"
msgstr ""

#: ../../RackQuickstart.rst:408
msgid ""
"Just pay attention you need a uWSGI binary (or a plugin if you are using "
"a modular build) for every Ruby version (that's Ruby version, not "
"gemset!)."
msgstr ""

#: ../../RackQuickstart.rst:410
msgid ""
"If you are interested, this is a list of commands to build the uWSGI core"
" + 1 one plugin per every Ruby version installed in rvm:"
msgstr ""

#: ../../RackQuickstart.rst:424
msgid "Then if you want to use ruby 1.9.2 with the @oops gemset:"
msgstr ""

#: ../../RackQuickstart.rst:441
msgid "Automatically starting uWSGI on boot"
msgstr ""

#: ../../RackQuickstart.rst:443
msgid ""
"If you are thinking about firing up vi and writing an init.d script for "
"spawning uWSGI, just sit (and calm) down and make sure your system "
"doesn't offer a better (more modern) approach first."
msgstr ""

#: ../../RackQuickstart.rst:445
msgid ""
"Each distribution has chosen a startup system (:doc:`Upstart<Upstart>`, "
":doc:`Systemd`...) and there are tons of process managers available "
"(supervisord, god, monit, circus...)."
msgstr ""

#: ../../RackQuickstart.rst:447
msgid ""
"uWSGI will integrate very well with all of them (we hope), but if you "
"plan to deploy a big number of apps check the uWSGI "
":doc:`Emperor<Emperor>` - it is more or less the dream of every devops "
"engineer."
msgstr ""

#: ../../RackQuickstart.rst:450
msgid "Security and availability"
msgstr ""

#: ../../RackQuickstart.rst:452
msgid ""
"ALWAYS avoid running your uWSGI instances as root. You can drop "
"privileges using the uid and gid options."
msgstr ""

#: ../../RackQuickstart.rst:466
msgid ""
"A common problem with webapp deployment is \"stuck requests\". All of "
"your threads/workers are stuck blocked on a request and your app cannot "
"accept more of them."
msgstr ""

#: ../../RackQuickstart.rst:468
msgid ""
"To avoid that problem you can set an ``harakiri`` timer. It is a monitor "
"(managed by the master process) that will destroy processes stuck for "
"more than the specified number of seconds."
msgstr ""

#: ../../RackQuickstart.rst:482
msgid ""
"This will destroy workers blocked for more than 30 seconds. Choose the "
"harakiri value carefully!"
msgstr ""

#: ../../RackQuickstart.rst:484
msgid ""
"In addition to this, since uWSGI 1.9, the stats server exports the whole "
"set of request variables, so you can see (in real time) what your "
"instance is doing (for each worker, thread or async core)"
msgstr ""

#: ../../RackQuickstart.rst:486
msgid "Enabling the stats server is easy:"
msgstr ""

#: ../../RackQuickstart.rst:501
msgid ""
"just bind it to an address (UNIX or TCP) and just connect (you can use "
"telnet too) to it to receive a JSON representation of your instance."
msgstr ""

#: ../../RackQuickstart.rst:503
msgid ""
"The ``uwsgitop`` application (you can find it in the official github "
"repository) is an example of using the stats server to have a top-like "
"realtime monitoring tool (with fancy colors!)"
msgstr ""

#: ../../RackQuickstart.rst:506
msgid "Memory usage"
msgstr ""

#: ../../RackQuickstart.rst:508
msgid "Low memory usage is one of the selling point of the whole uWSGI project."
msgstr ""

#: ../../RackQuickstart.rst:510
msgid ""
"Unfortunately being aggressive with memory by default could (read well: "
"could) lead to some performance problems."
msgstr ""

#: ../../RackQuickstart.rst:512
msgid ""
"By default the uWSGI Rack plugin calls the Ruby GC (garbage collector) "
"after every request. If you want to reduce this rate just add the ``--rb-"
"gc-freq <n>`` option, where n is the number of requests after the GC is "
"called."
msgstr ""

#: ../../RackQuickstart.rst:514
msgid ""
"If you plan to make benchmarks of uWSGI (or compare it with other "
"solutions) take in account its use of GC."
msgstr ""

#: ../../RackQuickstart.rst:516
msgid ""
"Ruby can be a real memory devourer, so we prefer to be aggressive with "
"memory by default instead of making hello-world benchmarkers happy."
msgstr ""

#: ../../RackQuickstart.rst:519
msgid "Offloading"
msgstr ""

#: ../../RackQuickstart.rst:521
msgid ""
":doc:`OffloadSubsystem` allows you to free your workers as soon as "
"possible when some specific pattern matches and can be delegated to a "
"pure-c thread. Examples are sending static file from the file system, "
"transferring data from the network to the client and so on."
msgstr ""

#: ../../RackQuickstart.rst:524
msgid ""
"Offloading is very complex, but its use is transparent to the end user. "
"If you want to try just add ``--offload-threads <n>`` where <n> is the "
"number of threads to spawn (1 per CPU is a good value to start with)."
msgstr ""

#: ../../RackQuickstart.rst:526
msgid ""
"When offload threads are enabled, all of the parts that can be optimized "
"will be automatically detected."
msgstr ""

#: ../../RackQuickstart.rst:530
msgid "And now"
msgstr ""

#: ../../RackQuickstart.rst:532
msgid ""
"You should already be able to go in production with such few concepts, "
"but uWSGI is an enormous project with hundreds of features and "
"configurations. If you want to be a better sysadmin, continue reading the"
" full docs."
msgstr ""

#: ../../RackQuickstart.rst:535
msgid "Welcome!"
msgstr ""

