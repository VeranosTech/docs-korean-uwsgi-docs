# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2012-2016, uWSGI
# This file is distributed under the same license as the uWSGI package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2019.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: uWSGI 2.0\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2019-05-09 10:15+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.6.0\n"

#: ../../tutorials/CachingCookbook.rst:2
msgid "The uWSGI Caching Cookbook"
msgstr ""

#: ../../tutorials/CachingCookbook.rst:4
msgid ""
"This is a cookbook of various caching techniques using "
":doc:`../InternalRouting`, :doc:`../Caching` and "
":doc:`../Transformations`"
msgstr ""

#: ../../tutorials/CachingCookbook.rst:6
msgid ""
"The examples assume a modular uWSGI build. You can ignore the 'plugins' "
"option, if you are using a monolithic build."
msgstr ""

#: ../../tutorials/CachingCookbook.rst:8
msgid "Recipes are tested over uWSGI 1.9.7. Older versions may not work."
msgstr ""

#: ../../tutorials/CachingCookbook.rst:11
msgid "Let's start"
msgstr ""

#: ../../tutorials/CachingCookbook.rst:13
msgid ""
"This is a simple perl/PSGI Dancer app we deploy on an http-socket with 4 "
"processes."
msgstr ""

#: ../../tutorials/CachingCookbook.rst:25
msgid ""
"This is the uWSGI config. Pay attention to the log-micros directive. The "
"objective of uWSGI in-memory caching is generating a response in less "
"than 1 millisecond (yes, this is true), so we want to get the response "
"time logging in microseconds (thousandths of a millisecond)."
msgstr ""

#: ../../tutorials/CachingCookbook.rst:45
msgid ""
"Run the uWSGI instance in your terminal and just make a bunch of requests"
" to it."
msgstr ""

#: ../../tutorials/CachingCookbook.rst:51
msgid "If all goes well you should see something similar in your uWSGI logs:"
msgstr ""

#: ../../tutorials/CachingCookbook.rst:62
msgid "while cURL will return:"
msgstr ""

#: ../../tutorials/CachingCookbook.rst:74
msgid ""
"The first request on a process took about 3 milliseconds (this is normal "
"as lot of code is executed for the first request), but the following run "
"in about 1 millisecond."
msgstr ""

#: ../../tutorials/CachingCookbook.rst:76
msgid "Now we want to store the response in the uWSGI cache."
msgstr ""

#: ../../tutorials/CachingCookbook.rst:79
msgid "The first recipe"
msgstr ""

#: ../../tutorials/CachingCookbook.rst:81
msgid ""
"We first create a uWSGI cache named 'mycache' with 100 slots of 64 KiB "
"each (new options are at the end of the config) and for each request for "
"'/' we search in it for a specific item named 'myhome'."
msgstr ""

#: ../../tutorials/CachingCookbook.rst:83
msgid ""
"This time we load the ``router_cache`` plugin too (though it is built-in "
"by default in monolithic servers)."
msgstr ""

#: ../../tutorials/CachingCookbook.rst:108
msgid ""
"Restart uWSGI and re-run the previous test with cURL. Sadly nothing will "
"change. Why?"
msgstr ""

#: ../../tutorials/CachingCookbook.rst:110
msgid ""
"Because you did not instruct uWSGI to store the plugin response in the "
"cache. You need to use the ``cachestore`` routing action..."
msgstr ""

#: ../../tutorials/CachingCookbook.rst:137
#, python-format
msgid ""
"Now re-run the test, and you should see requests going down to a range of"
" 100-300 microseconds. The gain depends on various factors, but you "
"should gain at least 60% in response time."
msgstr ""

#: ../../tutorials/CachingCookbook.rst:139
msgid "The log line reports -1 as the app id:"
msgstr ""

#: ../../tutorials/CachingCookbook.rst:145
msgid ""
"This is because when a response is served from the cache your app/plugin "
"is not touched (in this case, no perl call is involved)."
msgstr ""

#: ../../tutorials/CachingCookbook.rst:147
msgid "You will note less headers too:"
msgstr ""

#: ../../tutorials/CachingCookbook.rst:157
msgid ""
"This is because only the body of a response is cached. By default the "
"generated response is set as text/html but you can change it or let the "
"MIME type engine do the work for you (see later)."
msgstr ""

#: ../../tutorials/CachingCookbook.rst:161
msgid "Cache them all !!!"
msgstr ""

#: ../../tutorials/CachingCookbook.rst:163
msgid ""
"We want to cache all of our requests. Some of them returns images and "
"css, while the others are always text/html"
msgstr ""

#: ../../tutorials/CachingCookbook.rst:200
msgid "Multiple caches"
msgstr ""

#: ../../tutorials/CachingCookbook.rst:202
msgid ""
"You may want/need to store items in different caches. We can change the "
"previous recipe to use three different caches for images, css and html "
"responses."
msgstr ""

#: ../../tutorials/CachingCookbook.rst:249
msgid ""
"Important, every matched 'cachestore' will overwrite the previous one. So"
" we are adding .* as the first rule."
msgstr ""

#: ../../tutorials/CachingCookbook.rst:252
msgid "Being more aggressive, the Expires HTTP header"
msgstr ""

#: ../../tutorials/CachingCookbook.rst:254
msgid ""
"You can set an expiration for each cache item. If an item has an expire, "
"it will be translated to HTTP Expires headers. This means that once you "
"have sent a cache item to the browser, it will not request it until it "
"expires!"
msgstr ""

#: ../../tutorials/CachingCookbook.rst:257
msgid "We use the previous recipe simply adding different expires to the items."
msgstr ""

#: ../../tutorials/CachingCookbook.rst:303
msgid ""
"images and stylesheets are cached for 1 hour, while html response are "
"cached for 1 minute"
msgstr ""

#: ../../tutorials/CachingCookbook.rst:306
msgid "Monitoring Caches"
msgstr ""

#: ../../tutorials/CachingCookbook.rst:308
msgid "The stats server exposes cache information."
msgstr ""

#: ../../tutorials/CachingCookbook.rst:310
msgid ""
"There is an ncurses-based tool "
"(https://pypi.python.org/pypi/uwsgicachetop) using that information."
msgstr ""

#: ../../tutorials/CachingCookbook.rst:314
msgid "Storing GZIP variant of an object"
msgstr ""

#: ../../tutorials/CachingCookbook.rst:316
msgid ""
"Back to the first recipe. We may want to store two copies of a response. "
"The \"clean\" one and a gzipped one for clients supporting gzip encoding."
msgstr ""

#: ../../tutorials/CachingCookbook.rst:318
msgid ""
"To enable the gzip copy you only need to choose a name for the item and "
"pass it as the 'gzip' option of the cachestore action."
msgstr ""

#: ../../tutorials/CachingCookbook.rst:320
msgid ""
"Then check for HTTP_ACCEPT_ENCODING request header. If it contains the "
"'gzip' word you can send it the gzip variant."
msgstr ""

#: ../../tutorials/CachingCookbook.rst:350
msgid "Storing static files in the cache for fast serving"
msgstr ""

#: ../../tutorials/CachingCookbook.rst:352
msgid ""
"You can populate a uWSGI cache on server startup with static files for "
"fast serving them. The option --load-file-in-cache is the right tool for "
"the job"
msgstr ""

#: ../../tutorials/CachingCookbook.rst:363
msgid ""
"You can specify all of the --load-file-in-cache directive you need but a "
"better approach would be"
msgstr ""

#: ../../tutorials/CachingCookbook.rst:376
msgid "this will store all of the html files in /usr/share/doc/socat."
msgstr ""

#: ../../tutorials/CachingCookbook.rst:378
msgid "Items are stored with the path as the key."
msgstr ""

#: ../../tutorials/CachingCookbook.rst:380
msgid ""
"When a non-existent item is requested the connection is closed and you "
"should get an ugly"
msgstr ""

#: ../../tutorials/CachingCookbook.rst:387
msgid ""
"This is because the internal routing system failed to manage the request,"
" and no request plugin is available to manage the request."
msgstr ""

#: ../../tutorials/CachingCookbook.rst:389
msgid ""
"You can build a better infrastructure using the simple 'notfound' plugin "
"(it will always return a 404)"
msgstr ""

#: ../../tutorials/CachingCookbook.rst:403
msgid ""
"You can store file in the cache as gzip too using --load-file-in-cache-"
"gzip"
msgstr ""

#: ../../tutorials/CachingCookbook.rst:405
msgid ""
"This option does not allow to set the name of the cache item, so to "
"support client iwith and without gzip support we can use 2 different "
"caches"
msgstr ""

#: ../../tutorials/CachingCookbook.rst:424
msgid "Caching for authenticated users"
msgstr ""

#: ../../tutorials/CachingCookbook.rst:426
msgid ""
"If you authenticate users with http basic auth, you can differentiate "
"caching for each one using the ${REMOTE_USER} request variable:"
msgstr ""

#: ../../tutorials/CachingCookbook.rst:458
msgid ""
"Cookie-based authentication is generally more complex, but the vast "
"majority of time a session id is passed as a cookie."
msgstr ""

#: ../../tutorials/CachingCookbook.rst:460
msgid "You may want to use this session_id as the key"
msgstr ""

#: ../../tutorials/CachingCookbook.rst:489
msgid ""
"Obviously a malicious user could build a fake session id and could "
"potentially fill your cache. You should always check the session id. "
"There is no single solution, but a good example for file-based php "
"session is the following one:"
msgstr ""

#: ../../tutorials/CachingCookbook.rst:521
msgid "Caching to files"
msgstr ""

#: ../../tutorials/CachingCookbook.rst:523
msgid "Sometimes, instead of caching in memory you want to store static files."
msgstr ""

#: ../../tutorials/CachingCookbook.rst:525
msgid "The transformation_tofile plugin allows you to store responses in files:"
msgstr ""

#: ../../tutorials/CachingCookbook.rst:548
msgid ""
"the hex[] routing var take a request variable content and encode it in "
"hexadecimal. As PATH_INFO tend to contains / it is a better approach than"
" storing full path names (or using other encoding scheme like base64 that"
" can include slashes too)"
msgstr ""

